# PaymentsController Overview

PaymentsController.sol manages payment flows for credential verification, handling crediting and debiting verifiers and issuers accordingly. 
- includes an expense accounting system to allocate subsidies for verifiers who stake MOCA tokens
- issuers' gross verification fees subject to a haircut, which goes to the protocol, and voters [VotingController]. 

PaymentsController is architected for high-throughput, low-latency operations, with a focus on minimizing gas costs in core transaction flows. 
- Gas optimization is prioritized in `deductBalance` and `deductBalanceZeroFee`, as these functions are invoked at scale—potentially millions of times.
- The contract leverages hybrid memory-storage access patterns and selective updates to ensure efficiency under sustained, high-frequency usage.

## Table of Contents

- [Key Features](#key-features)
- [1. Contract Overview](#1-contract-overview)
    - [Issuer Onboarding](#issuer-onboarding)
    - [Verifier Onboarding](#verifier-onboarding)
    - [Schemas: The Credential Blueprint](#schemas-the-credential-blueprint)
- [2. Design Choices](#2-design-choices)
  - [The deductBalance Pattern](#the-deductbalance-pattern)
    - [Design Rationale](#design-rationale)
    - [Gas Savings Breakdown](#gas-savings-breakdown)
    - [Zero-Fee Credentials: Separate Function](#zero-fee-credentials-separate-function)
  - [Subsidy System: Exact Staking Amounts](#subsidy-system-exact-staking-amounts)
- [3. Contract Functions Walkthrough](#3-contract-functions-walkthrough)
  - [deductBalance()](#deductbalance)
  - [Fee Distribution Model](#fee-distribution-model)
  - [Administrative Functions](#administrative-functions)
- [4. Execution Flows](#4-execution-flows)
  - [Typical Verification Flow](#typical-verification-flow)
  - [Issuer: claiming fees](#issuer-claiming-fees)
- [5. Integration Points](#5-integration-points)
- [6. Timing and Epoch Considerations](#6-timing-and-epoch-considerations)
  - [Epoch Framework](#epoch-framework)
  - [Time-Dependent Operations](#time-dependent-operations)
- [7. Risk Management](#7-risk-management)
- [8. Upgrade Architecture](#8-upgrade-architecture)
- [Appendix: Technical Deep Dives](#appendix-technical-deep-dives)
  - [Gas Optimization Detailed Analysis](#gas-optimization-detailed-analysis)
  - [Precision and Rounding](#precision-and-rounding)
  - [Emergency Scenarios](#emergency-scenarios)
- [Others](#others)

## Key Features

### 1. **Hybrid Storage-Memory Optimization for High-Frequency Functions**
- `deductBalance()`, called on every credential verification, employs a dual-reference pattern that reduces gas consumption by ~40%.
- Reads are performed from memory (3 gas) while writes use storage pointers (100 gas), optimizing for the common case of multiple reads per write.

This pattern is critical for a function that may be called millions of times daily.

### 2. **Three-Actor Economic Model**
- `Verifiers`: Pay for credential verifications, can stake MOCA for subsidies
- `Issuers`: Create credential schemas and earn fees from verifications
- `Voters`: Receive a cut of verification fees for participating in governance
- `Protocol`: Receives a cut of verification fees for treasury

### 3. **Dynamic Fee System with Time-Delayed Increases**
- Fee decreases apply immediately to benefit users
- Fee increases are delayed by a configurable period (min: 1 epoch) to prevent sudden price hikes

This protects verifiers from unexpected cost increases while allowing issuers flexibility in pricing.

### 4. **Staking-Based Subsidy Tiers**
- Verifiers have to stake exact MOCA amounts to unlock subsidy percentages
- Subsidies are calculated on gross fees and tracked per epoch for distribution 
- Subsidies are collected as USD8, as are fees. 

Subsidies are distributed via `VotingController` contract on an epoch basis; in the form of `esMoca`.
*Note: Subsidies are accrued in USD8 within PaymentsController, converted to esMOCA off-chain, then distributed via VotingController.*

### 5. **Zero-Fee Credential Support**

The `deductBalanceZeroFee` function is dedicated to handling free credential verifications. 
- Removes unnecessary fee logic and signature parameters for zero-fee flows 
- Streamlines execution and reduces gas costs for free credential use cases 
- Simplifies logic for scenarios where is free

This significantly helps reduce the gas footprint of `deductBalance` allowing for more throughput as well, while accommodating for a low-probability scenario for feature completeness.

### 6. **Integration with Voting Pools**

Schemas can be linked to voting pools to facilitate voter rewards. 
- Pool associations are updatable mid-epoch, with explicit rules governing subsidy eligibility 
- Supports dynamic governance participation incentives and flexible reward distribution

### 7. **Emergency Risk Management**

- Implements multi-tiered access control with specialized roles 
- Provides pause/unpause functionality for operational contingencies 
- Features a one-way freeze kill-switch and emergency exit procedures 
- Ensures user funds remain recoverable under all circumstances

## Notes to auditors

1. There is a possibility that the same signer can be added to multiple verifiers, without the signer's permission. Known and accepted.
2. Signature can be submitted by anyone, so frontrun and causing a revert is for deductBalance is possible. This is an accepted risk, but must be fixed in the future by deploying a new payment controller contract if universal verifier is used.
3. Bypass verification fee where the FE does the verification but there's no onchain deduction is known issue and accepted risk. Should be mitigated in the future by making verification go through universal verifier and also call deductBalance atomically.
4. Signer limitation to prevent draining of verifier balance will be done off-chain, at API level.

------

# 1. **Contract Overview**

## Financial Tracking
```solidity
// Subsidy tracking for VotingController integration
mapping(uint256 epoch => mapping(bytes32 poolId => uint256 totalSubsidies)) _epochPoolSubsidies;
mapping(uint256 epoch => mapping(bytes32 poolId => mapping(bytes32 verifierId => uint256))) _epochPoolVerifierSubsidies;

// Fee tracking for rewards distribution
mapping(uint256 epoch => mapping(bytes32 poolId => DataTypes.FeesAccrued)) _epochPoolFeesAccrued;
mapping(uint256 epoch => DataTypes.FeesAccrued) _epochFeesAccrued;
```

**These mappings enable:**
- Precise tracking of subsidies per verifier per pool per epoch
- Accurate fee distribution to protocol and voters
- Epoch-based accounting for clean financial reconciliation

## Nonce System

PaymentsController uses two separate nonce systems:

### 1. Verifier Signature Nonces
```solidity
mapping(address signerAddress => mapping(address userAddress => uint256 nonce)) internal _verifierNonces;
```
- Prevents replay attacks on `deductBalance()` and `deductBalanceZeroFee()` 
- Tracked per signer per user (not stored in Verifier struct due to updatable signerAddress)
- Incremented on every successful verification
- Queryable via `getVerifierNonce(signerAddress, userAddress)`

### 2. Entity Creation Nonces
```solidity
mapping(address callerAddress => mapping(DataTypes.EntityType entityType => uint256 nonce)) internal _callerNonces;
```
- Used for deterministic ID generation with collision prevention
- Tracked per caller per entity type (ISSUER, VERIFIER, SCHEMA)
- Incremented when collision detected during ID generation
- Queryable via `getCallerNonce(caller, entityType)`
- Ensures globally unique IDs across all entity types

## Actor Data

```solidity
// Primary actor mappings
mapping(bytes32 issuerId => DataTypes.Issuer) internal _issuers;
mapping(bytes32 verifierId => DataTypes.Verifier) internal _verifiers;
mapping(bytes32 schemaId => DataTypes.Schema) internal _schemas;
```

## Constructor & Initialization

The constructor sets up all immutable parameters and initial role assignments:

```solidity
constructor(
    address globalAdmin,
    address paymentsControllerAdmin,
    address monitorAdmin,
    address cronJobAdmin,
    address monitorBot,
    address paymentsControllerTreasury,
    address emergencyExitHandler,
    uint256 protocolFeePercentage,
    uint256 voterFeePercentage,
    uint256 delayPeriod,
    address wMoca_,
    address usd8_,
    uint256 mocaTransferGasLimit,
    string memory name,
    string memory version
)
```

**Key Validations:**
- All addresses must be non-zero
- Treasury cannot be contract address itself
- `protocolFeePercentage + voterFeePercentage < 10000` (cannot equal or exceed 100%)
- `delayPeriod >= EpochMath.EPOCH_DURATION` (minimum 1 epoch)
- `delayPeriod` must be valid epoch time (divisible by epoch duration)
- `mocaTransferGasLimit >= 2300` gas

**Role Setup:**
- DEFAULT_ADMIN_ROLE → globalAdmin (can manage all role admins)
- PAYMENTS_CONTROLLER_ADMIN_ROLE → paymentsControllerAdmin (managed by DEFAULT_ADMIN)
- MONITOR_ADMIN_ROLE → monitorAdmin (managed by DEFAULT_ADMIN)
- CRON_JOB_ADMIN_ROLE → cronJobAdmin (managed by DEFAULT_ADMIN)
- EMERGENCY_EXIT_HANDLER_ROLE → emergencyExitHandler (managed by DEFAULT_ADMIN)
- MONITOR_ROLE → monitorBot (managed by MONITOR_ADMIN)
- CRON_JOB_ROLE → not assigned at deployment (managed by CRON_JOB_ADMIN)

**Hierarchical Role Management:**
- High-level admins managed by DEFAULT_ADMIN_ROLE (global admin)
- High-frequency operational roles (MONITOR, CRON_JOB) managed by dedicated admins
- Enables flexible role rotation without global admin intervention

## Actor Workflows

### Issuer Onboarding

1. Create Profile: Call `createIssuer(assetAddress)` to receive unique `issuerId`
2. Create Schemas: Call `createSchema(issuerId, fee)` for each credential type
3. Manage Fees: Update schema fees as needed (decreases immediate, increases delayed)
4. Claim Revenue: Periodically claim accumulated fees to asset address

#### Issuer Structure

`function createIssuer(address assetAddress) external returns (bytes32)`
- returns `issuerId`, for integration with middleware translation layer.

The following struct defines the on-chain attributes of an issuer:

```solidity
    struct Issuer {
        bytes32 issuerId;
        address adminAddress;       // for interacting w/ contract 
        address assetAddress;       // for claiming fees 
                
        // credentials
        uint128 totalVerified; // incremented on each verification
        
        // USD8 | 6dp precision
        uint128 totalNetFeesAccrued;    // net of protocol and voter fees
        uint128 totalClaimed;

        uint128 totalSchemas;       // track schemas created by issuer
    }
```

- `issuerId`: Deterministically generated `bytes32` identifier assigned at issuer creation
- `adminAddress`: Set to `msg.sender` at creation; serves as the issuer's control address for contract interactions (e.g., schema management, fee updates, address changes). **Immutable - cannot be changed.**
- `assetAddress`: Provided at creation; acts as the designated wallet for claiming accrued fees.

**ID Generation & Collision Prevention:**
- Uses deterministic generation with nonce: `keccak256(abi.encode("ISSUER", msg.sender, salt))`
- Checks for collisions across ALL entity types (issuers, verifiers, schemas)
- Automatically increments nonce if collision detected
- Ensures globally unique IDs across the system
- Nonce tracked per caller per entity type in `_callerNonces` mapping

The `assetAddress` is dedicated solely to fee withdrawals, while the `adminAddress` is required for all issuer-initiated contract actions. 
This separation enables issuers to maintain distinct operational and treasury controls, supporting flexible security postures.

The `adminAddress` is immutable, and cannot be changed by an issuer. 
- If their admin address is compromised, they will have to create a new issuer profile with a new admin address (new issuerId).
- Fees unclaimed under their previous issuer profile, would be lost, assuming the attacked immediately called `updateAssetAddress` and `claimFees`, the moment the admin address was exploited.

**Rationale for assigning issuers an on-chain id:**
- Enables updates of asset addresses without recreating or migrating profiles.
- Facilitates granular access control, allowing issuers to assign different addresses for configuration and asset management
- Allows address rotation without profile migration

*Without an on-chain issuer ID, issuers would be forced to use a **single address** for all actions, limiting flexibility and upgradability.*

### Verifier Onboarding

1. Create Profile: Call `createVerifier(signerAddress, assetManagerAddress)` to receive unique `verifierId`
2. Deposit Funds: Transfer USD8 via `deposit()` to fund verifications
3. Operate: Sign verification requests that deduct from balance
4. Optional Staking: Stake native MOCA via `stakeMoca()` to unlock subsidy tiers

#### Verifier Structure

`function createVerifier(address signerAddress, address assetManagerAddress) external returns (bytes32)`
- returns `verifierId`, for integration with middleware translation layer

The following struct defines the on-chain attributes of a verifier:

```solidity
    struct Verifier {
        bytes32 verifierId;
        address adminAddress;           // msg.sender
        address assetManagerAddress;    // used for deposit/withdrawing USD8 + staking/unstaking native MOCA
        address signerAddress;

        // Native MOCA | 18 dp precision
        uint128 mocaStaked;

        // USD8 | 6dp precision
        uint128 currentBalance;
        uint128 totalExpenditure;      // count: never decremented
    }
```
- `verifierId`: Deterministically generated `bytes32` identifier assigned at verifier creation
- `adminAddress`: Assigned at verifier creation (`msg.sender`); controls verifier configuration, key rotation, and operational actions. **Immutable - cannot be changed.**
- `signerAddress`: Used exclusively for EIP-712 signature validation on verification payments; can be updated independently for key rotation.
- `assetManagerAddress`: Dedicated for deposit/withdrawal of USD8 balances and staking/unstaking native MOCA; enables separation of treasury and operational controls.

**ID Generation & Collision Prevention:**
- Uses deterministic generation with nonce: `keccak256(abi.encode("VERIFIER", msg.sender, salt))`
- Checks for collisions across ALL entity types (issuers, verifiers, schemas)
- Automatically increments nonce if collision detected
- Ensures globally unique IDs across the system
- Nonce tracked per caller per entity type in `_callerNonces` mapping

Verifiers are assigned distinct `admin`, `signer`, and `assetManager` addresses, enabling independent management of operational permissions, signature authority, and treasury controls. 
This modular approach supports secure key rotation and flexible access strategies.

The `adminAddress` is immutable, and cannot be changed by a verifier. 
- If their admin address is compromised, they will have to create a new profile with a new admin address (new verifierId).
- USD8 balances and native MOCA staked under their previous profile, would be lost; assuming the attacker immediately called `updateAssetManagerAddress` followed by `withdraw` and `unstakeMoca`, the moment the admin address was exploited.

**Native MOCA Staking:**
- `stakeMoca()` accepts native MOCA via `msg.value` (payable function)
- Native MOCA is stored directly in the contract balance
- `unstakeMoca()` transfers native MOCA back to verifier's assetManagerAddress
- If native transfer fails (e.g., contract recipient without receive/fallback), automatically wraps to wMOCA and transfers wMOCA instead (via `LowLevelWMoca`)

**Rationale for On-Chain Verifier ID:**
- Independent admin, asset, and signer address management for robust key rotation
- Enables updating of signer and asset addresses without recreating or migrating profiles.
- Supports separation of signature and asset management roles for enhanced security
- Facilitates granular access control and adaptable organizational wallet structures

*Without an on-chain verifier ID, verifiers would be forced to use a **single address** for all actions, limiting flexibility and upgradability. This design ensures they can adapt their address management as their operational requirements evolve.*

### Schemas: The Credential Blueprint

A schema defines the structure and rules for a credential type. Think of it as a blueprint that specifies:

**Off-chain components (not stored in contract):**
- Public metadata: title, data source type, version, header information
- Technical specifications: zk-proof requirements, encryption parameters
- Private validation rules: allowed claims, data types, constraints

**On-chain components (stored in PaymentsController):**
- Financial parameters: current fee, pending fee updates
- Usage metrics: verification counts, fees accumulated
- Governance links: optional voting pool association

#### Creating Schemas

`function createSchema(bytes32 issuerId, uint128 fee) external returns (bytes32)`

When an issuer calls `createSchema`, the contract:
1. Generates a unique `bytes32` schemaId
2. Links it to the issuer
3. Sets the initial verification fee
4. Initializes counters for tracking usage

#### Schema Structure

```solidity
    struct Schema {
        bytes32 schemaId;
        bytes32 issuerId;
        
        // fees are expressed in USD8 terms | 6dp precision
        uint128 currentFee;
        uint128 nextFee;
        uint128 nextFeeTimestamp;       

        // counts: never decremented
        uint128 totalVerified;
        uint128 totalGrossFeesAccrued;            // disregards protocol and voting fees

        // for VotingController
        bytes32 poolId;
    }
```

`schemaId` is generated with collision prevention:

```solidity
// Generate deterministic schemaId with collision checking
uint256 totalSchemas = _issuers[issuerId].totalSchemas;
uint256 salt = _callerNonces[msg.sender][DataTypes.EntityType.SCHEMA];

bytes32 schemaId = keccak256(abi.encode("SCHEMA", issuerId, totalSchemas, salt));
while (
    _issuers[schemaId].adminAddress != address(0) 
    || _verifiers[schemaId].adminAddress != address(0) 
    || _schemas[schemaId].issuerId != bytes32(0)
) {
    schemaId = keccak256(abi.encode("SCHEMA", issuerId, totalSchemas, ++salt));
}
```

**Key Points:**
- Checks all three mappings (_issuers, _verifiers, _schemas) for collisions
- Increments salt until unique ID found
- Ensures global uniqueness across all entity types

#### On-chain vs Off-chain Design

The PaymentsController only stores schema financial data, not credential logic.
- **On-chain**: Fees, metrics, pool associations
- **Off-chain**: Credential logic, validation rules, metadata
- **Middleware**: Maps schemaIds to off-chain definitions

>Benefits: Gas efficiency, evolution without upgrades, and logic confidentiality.

#### Schema Fee Management

Issuers can update schema fees with built-in protections:
- **Decreases**: Apply immediately to benefit verifiers
- **Increases**: Subject to delay (minimum 1 epoch) to prevent price shocks

#### Voting Pool Integration

Schemas can be associated with voting pools to enable voter rewards:

```solidity
updatePoolId(bytes32 schemaId, bytes32 poolId)  // Admin function
```

**Pool Association Rules:**
- Default: `poolId = bytes32(0)` (no voting pool)
- Can be updated mid-epoch with clear subsidy implications
- Pools are created in VotingController, referenced here

**Important Timing Considerations:**
- **Adding mid-epoch**: Prior verifications in that epoch won't qualify for subsidies
- **Removing mid-epoch**: Weight excluded from pool calculations; prior verifications forfeit subsidies
- **Best practice**: Update pool associations at epoch boundaries when possible

This design enables dynamic governance participation while maintaining clear rules about subsidy eligibility.

#### Pool Whitelisting

Schemas can only be associated with **whitelisted pools**. This two-step process ensures pool validity:

1. **Admin whitelists pool**: `whitelistPool(poolId, true)` - marks pool as valid
2. **Admin associates schema**: `updatePoolId(schemaId, poolId)` - links schema to whitelisted pool

```solidity
mapping(bytes32 poolId => bool isWhitelisted) public votingPools;
```

**Key Points:**
- Pool must exist in VotingController before whitelisting
- `updatePoolId()` will revert if pool is not whitelisted
- Pools can be un-whitelisted: `whitelistPool(poolId, false)`
- Setting `poolId = bytes32(0)` removes pool association (doesn't require whitelist check)

This mechanism prevents schemas from being linked to non-existent or invalid pools.

---

# 2. **Design Choices**

## The deductBalance Pattern 

The `deductBalance` function is the most frequently called function in the PaymentsController, executed on every credential verification. 
- in a high-throughput environment, even small gas inefficiencies compound into significant costs.
- hence, we have implemented a hybrid storage-memory optimization pattern that reduces gas consumption by approximately 40%.

**Traditional Approach Problem:**
- Pure storage reads: Each field access costs ~100 gas
- Schema has 8-10 fields accessed per verification
- Total cost: 800-1000 gas just for reads

**The Hybrid Approach**
We employ a dual-reference pattern that optimizes for both read and write operations:

```solidity
// Storage pointer for write operations
DataTypes.Schema storage schemaStorage = _schemas[schemaId];

// Memory copy for read operations  
DataTypes.Schema memory schema = schemaStorage;
```

**This pattern allows us to:**

1. Read efficiently: Access struct fields from memory (3 gas) instead of storage (100 gas)
2. Write selectively: Update storage only when necessary using the storage pointer
3. Maintain consistency: Keep a clear separation between read and write operations

### Design Rationale

**Why Hybrid Instead of Pure Memory?**
- Conditional Updates: Fee updates only occur when conditions are met
- Atomic Operations: Storage updates must be atomic for consistency
- Memory Limitations: Full memory copy would be wasteful for conditional writes

**Why Not Pure Storage?**
- Read Frequency: Schema fields are read 8-10 times per execution
- Calculation Needs: Multiple fields needed for fee calculations
- Cost Multiplication: Each storage read adds 100 gas

### Gas Savings Breakdown

| **Optimization Technique**| **Gas Saved**  | **Impact**                              |
|---------------------------|----------------|-----------------------------------------|
| Schema memory caching     | ~800 gas       | Eliminates 8 storage reads              |
| Verifier data caching     | ~200 gas       | Eliminates 2 storage reads              |
| Batch storage updates     | ~100 gas       | Reduces storage operation overhead      |
| Unchecked arithmetic      | ~80 gas        | Safe counters don't need overflow checks|
| **Total Savings**         | **~1,180 gas** | **~40% reduction**                      |


### Zero-Fee Credentials: Separate Function

`deductBalanceZeroFee` exists as a distinct function to handle zero-fee verification transactions.

***TLDR:*** 
- Adding zero-fee branching to `deductBalance` would increase gas costs for all standard (fee-bearing) verifications; the common case.
- Separation is intentional, as we do not expect zero-fee verifications be to be common.
- Additionally, prevents accidental fee deductions through explicit intent

## Subsidy System: Exact Staking Amounts

Verifiers must stake exact MOCA amounts (e.g., exactly 1000 MOCA for 10% subsidy), not ranges.

```solidity
mapping(uint256 mocaStaked => uint256 subsidyPercentage) _verifiersSubsidyPercentages;
```

- Predictability: Clear tiers without ambiguity
- Simplicity: Single mapping lookup, no range checking
- Anti-Gaming: Can't stake 999.99 to get benefits of 1000
- Flexibility: Admin can add/modify tiers without complex logic

# 3. **Contract Functions Walkthrough**

## `deductBalance()`

The `deductBalance()` function coordinates all payment and accounting steps for each credential verification.
It is the heart of the system.

1. **Signature Validation**
- Validates EIP-712 signature from the verifier’s authorized signer.
- Increments a nonce to prevent replay attacks.
- Confirms the verifier’s explicit approval for the transaction.

2. **Fee Management**
- Checks for any pending schema fee increases and applies them if the delay period has elapsed.
- Updates the current fee accordingly.
- Emits events to record fee changes.

3. **Balance Deduction & Distribution**
- Confirms the verifier has sufficient balance.
- Calculates protocol and voting fee portions.
- Atomically updates all relevant balances (verifier, issuer, protocol, voters).

4. **Subsidy Booking (Conditional)**
- Checks if verifier has staked, and is subject to which subsidy tier.
- Calculates subsidy based on gross fee, if eligible.
- Books subsidy for distribution at epoch end. [via `VotingController`]

5. **Global Accounting & Audit Trail**
- Increments verification counters for schema and issuer.
- Updates fee and subsidy records for each pool and epoch.
- Emits events to maintain a comprehensive audit trail.

**Note: Schema Fee Update Race Condition**

- User calls UVC at timestamp T1, where nextFeeTimestamp = T2
- Transaction mines at T2 + 1
- Fee increases from 10 USD to 100 USD
- User's signature had amount = 10
- Transaction reverts ❌

Impact: users can have valid transactions fail due to timing; aware and accepted.

---

### Fee Distribution Model

For each verification fee paid:
- **Issuer receives:** `Fee - Protocol Fee - Voting Fee`
- **Protocol receives:** `Fee × Protocol Fee Percentage`
- **Voters receive:** `Fee × Voting Fee Percentage`
- **Verifier may receive:** Subsidy based on staking tier (if eligible)

## Administrative Functions

### Fee Management

1. **`updateSchemaFee`:** Issuers can adjust schema fees with protection against sudden increases
2. **`updateProtocolFeePercentage:`** Protocol can adjust its fee share
3. **`updateVotingFeePercentage`:** Adjust voter reward percentage 
  
### Pool Integration

**`updatePoolId`:** Associate schemas with voting pools
- Enables voter rewards for specific credential types
- Can be updated mid-epoch with clear subsidy rules

### Pool Management

**`whitelistPool(bytes32 poolId, bool isWhitelisted)`:** Whitelist or un-whitelist a pool
- Only callable by PaymentsController admin
- Required before schemas can be associated with a pool
- Pool must exist in VotingController (verified off-chain)
- Emits `PoolWhitelistedUpdated` event

**`clearVerifierSubsidyTiers()`:** Remove all subsidy tiers
- Only callable by PaymentsController admin  
- Deletes entire `_subsidyTiers` array
- Useful for system resets or tier restructuring
- Emits `VerifierStakingTiersCleared` event

---

# 4. **Execution Flows**

## Typical Verification Flow
1. Verifier requests credential verification from user [`Initiated by user`]
2. Verifier signs EIP-712 message authorizing payment
3. Universal Verifier Contract calls PaymentsController.deductBalance()
4. PaymentsController:
    - Validates signature and amount
    - Deducts from verifier balance
    - Distributes fees to issuer/protocol/voters
    - Books subsidies if applicable
5. Verification proceeds with payment confirmed

## Issuer: claiming fees 
- Accumulated fees become claimable
- No epoch-based restrictions on claims
- Single transaction to claim all unclaimed fees

### Protocol: withdraw protocolFees & withdraw VotersFees
- Both fees withdrawable after epoch ends
- Clean separation of fee types for transparency

*However, protocol is allowed discretion when depositing into `VotingController`, hence `VotingController` does not integrate with `PaymentsController` to drive subsidy/reward claims.*

---

# 5. **Integration Points**

## Contract Dependencies

PaymentsController takes the following dependencies at deployment:
- **USD8 token**: Passed at deployment, stored as immutable - payment token for verification fees
- **wMOCA token**: Passed at deployment, stored as immutable - wrapped MOCA for fallback transfers
- **EIP-712 name/version**: Passed at deployment - for signature validation (name: "PaymentsController", version: "1")
- **AccessControlEnumerable**: Inherits from OpenZeppelin's AccessControlEnumerable for role-based access control
- **Pausable**: Inherits from OpenZeppelin's Pausable for emergency pause functionality
- **LowLevelWMoca**: Inherits for native MOCA transfer with automatic wrapping fallback
- **Gas Transfer Limit**: Configurable gas limit for MOCA transfers (minimum 2300 gas, default ~4029 for Gnosis Safe)

No central address registry (AddressBook) is used; all dependencies are set directly at deployment.

## With VotingController
- `PaymentsController` tracks subsidy & rewards accruals
- `VotingController` handles subsidy & rewards distribution
- Clean separation prevents circular dependencies
- Enables independent contract upgrades

## With LowLevelWMoca

PaymentsController inherits from `LowLevelWMoca` for native MOCA transfer fallback:
- Native MOCA transfers attempted first (gas-efficient for EOA recipients)
- If native transfer fails within gas limit (e.g., contract without receive/fallback), automatically wraps to wMOCA and transfers
- Used in `unstakeMoca()` and emergency exit functions
- Gas limit configurable via `setMocaTransferGasLimit()` (minimum 2300 gas)

---

# 6. **Timing and Epoch Considerations**

## Epoch Framework

PaymentsController operates on an epoch-based timeline that synchronizes with VotingController:
- **Epoch Duration**: Defined in EpochMath library (`14 days`)
- **Current Epoch**: Determined by `EpochMath.getCurrentEpochNumber()`
- **Epoch Boundaries**: Critical for subsidy calculations and fee withdrawals

## Time-Dependent Operations

### 1. Fee Increase Delays

**Minimum Delay**: 1 epoch (configurable via `FEE_INCREASE_DELAY_PERIOD`)

**Timeline Example:**
- Epoch N, Day 2: Issuer requests fee increase from 100 → 150 USD8
- System sets: nextFee = 150, nextFeeTimestamp = currentTime + DELAY
- Epoch N+1, Day 2: Fee automatically updates to 150 USD8
- All verifications from this point use new fee

**Key Points**:
- Delay must be in epoch intervals 
- Fee decreases bypass delay (immediate effect)
- Pending increases can be overridden by new updates

### 2. Pool Association Timing

Schemas can be associated with voting pools at any time, but timing affects subsidy eligibility:

**2.1: Adding Pool Association Mid-Epoch**:

Epoch N Timeline:
├─ Day 1-3: Schema has no pool (`poolId = 0`)
│ → Verifications accrue NO subsidies
├─ Day 4: Admin calls updatePoolId(schemaId, poolId)
│ → Association active
└─ Day 4-7: New verifications accrue subsidies

*Day 1-3 verifications are ineligible for subsidies.*

**2.2: Removing Pool Association Mid-Epoch**:

Epoch N Timeline:
├─ Day 1-3: Schema associated with poolId
│ → Verifications accrue subsidies
├─ Day 4: Admin sets poolId = 0
│ → Association removed
└─ Day 4-7: New verifications accrue NO subsidies

*Only day 1-3 subsidies are claimable.*
*Day 4-7 subsidies are FORFEITED.*


**Best Practice**: Update pool associations at epoch boundaries to avoid confusion.

### 3. Subsidy Distribution Timeline

Subsidies follow a multi-step process across epochs:

---

# 7. **Risk Management**

## Access Control Hierarchy

### Operational Roles
- **Payments Admin**: Configure fees, pools, and tiers
- **Asset Manager**: Withdraw protocol/voter fees
- **Monitor**: Pause contract in emergencies
- **Global Admin**: Unpause and freeze operations
- **Emergency Exit Handler**: Recover funds when frozen

### Security Features

1. **Pausable Operations**
   - All state-changing functions check pause status
   - Monitor can pause, only Global Admin can unpause
   - Prevents damage during active incidents

2. **Freeze Mechanism**
   - One-way operation requiring contract to be paused first
   - Enables emergency exit procedures
   - Cannot be reversed - kill-switch

3. **Emergency Exit**
   - Batch processing of verifier/issuer withdrawals
   - Only accessible when contract is frozen
   - Ensures users can always recover funds
   - Only callable by EmergencyExitHandler role

---

# 8. **Upgrade Architecture**

## Upgrade Process

1. **Deploy** new PaymentsController version
2. **Configure** new contract with existing actor data (optional migration functions)
3. **Update** VotingController to point to new contract [for subsidy references]
4. **Notify** verifiers to migrate USD8 balances and native MOCA stakes
5. **Freeze** old contract once migration complete

## Design for Upgradeability

- **Immutable Dependencies**: USD8, wMOCA, and AccessControlEnumerable set at deployment
- **Clean Interfaces**: Standardized role checking via AccessControlEnumerable inheritance
- **Financial Data Segmentation**: Financial data is segmented by epoch to enable straightforward migration and transition
- **Emergency Exit**: Ensures no funds locked during transition - verifiers can emergency exit their balances and stakes
- **Treasury Management**: Configurable treasury address via `setPaymentsControllerTreasury()` (DEFAULT_ADMIN_ROLE)
- **Granular Role System**: Uses AccessControlEnumerable for enumerable role management and flexible permission updates

---

# Note to Auditors

## Known and accepted risks

1. No limitation of signer that can be added to a verifier. Same signer can be added to multiple verifiers without the signer's approval.

2. Signature can be submitted by anyone, so frontrun and causing a revert is for deductBalance is possible. This is an accepted risk, but must be fixed in the future by deploying a new payment controller contract if universal verifier is used.

3. Bypass verification fee where the FE does the verification but there's no onchain deduction is known issue and accepted risk. Should be mitigated in the future by making verification go through universal verifier and also call deductBalance atomically.

4. Signer limitation to prevent draining of verifier balance will be done off chain at API level.

5. As the check for whether a verifier has approved the deduction to go towards a schema is only enforced off-chain, if the signer of a verifier signs a deduction for a schema which the verifier has not approved off-chain, it can still be executed, and the fee will be deducted from the verifier and go to the issuer.

6. As the deduct functionality functions which use up a signature can be called by anyone who has the signature (similar to https://www.trust-security.xyz/post/permission-denied) on behalf of the userAddress, if it should be called by a contract, denial of service can be done by front-running the function call with the same call parameters, accusing the verifier+userAddress nonce to increase. At this point of time, it will be called by either EOA or AA accounts, although the plan in the future is to have the UniversalVerifier contract call it to deduct after an onchain verification. However, if that is done, deductBalance has to either whitelist the caller of the function the UniversalVerifier. A redeploy for this contract with the guard will be required if such changes are made.

7. As it is expected for the SDK to get a signature from the verifier’s signer and call the deductBalance function as the user’s AA after the credential verification is done, it is possible for the client side to just drop the RPC request and not execute the transaction onchain. This is a known issue and accepted risk for now, if there are any actual abuse issues with this, other mitigation methods such as getting the signer or some operator who can get access to the signature or to submit the function call transaction for the user.

8. The verifier trusts the signer, so if the signer is compromised, it can drain the verifier’s balance by signing payloads for deduction.

9. signDeductBalance currently does not check that the user’s credentials are actually verified (success or attempted). This means that the user can make a request to the api to get a deduction signature and deduct the verifier’s balance to the schema’s issuer without providing any proof of verification.

# **Appendix: Technical Deep Dives**

## Gas Optimization Detailed Analysis

### Storage Access Patterns [`deductBalance()`]
```solidity
// Expensive: Multiple storage reads
uint128 fee = _schemas[schemaId].currentFee;        // 100 gas
uint128 nextFee = _schemas[schemaId].nextFee;       // 100 gas  
uint128 totalVerified = _schemas[schemaId].totalVerified; // 100 gas

// Optimized: Single storage read, multiple memory reads
DataTypes.Schema memory schema = _schemas[schemaId]; // 100 gas once
uint128 fee = schema.currentFee;                     // 3 gas
uint128 nextFee = schema.nextFee;                    // 3 gas
uint128 totalVerified = schema.totalVerified;        // 3 gas
```

### Unchecked Arithmetic
Safe to use `unchecked` blocks for:
- Counter increments (won't overflow in contract lifetime)
- Fee calculations (percentages ensure result < input)
- Balance deductions (already checked for sufficiency)

## Precision and Rounding

### Token Decimals
- **USD8**: 6 decimals (1 USD8 = 1,000,000 units)
- **MOCA**: 18 decimals (1 MOCA = 1,000,000,000,000,000,000 units)
- **esMOCA**: 18 decimals (same as MOCA)

### Fee Calculation Precision
- Percentages are in expressed in 2 decimal precision (XX.yy)
- range:[1–10_000] (100%: 10_000, 1%: 100, 0.1%: 10, 0.01%: 1)
- All fee calculations round down (favor issuers over protocol)

## Emergency Scenarios

### Scenario 1: Critical Bug Discovery
1. Monitor calls `pause()` - stops all operations
2. Team investigates and determines fix timeline
3. If fixable: Deploy fix, update VERIFIER_CONTRACT, `unpause()` when safe
4. If critical: `freeze()` and initiate emergency exit

### Scenario 2: Malicious Issuer
1. Cannot steal funds (only claim their earned fees)
2. Can manipulate schema fees (but with delay protection)
3. Verifiers protected by signature requirements
4. Worst case: Verifiers stop using malicious schemas

### Scenario 3: Contract Upgrade Failure  
1. Old contract continues operating normally
2. If new contract has issues: freeze old contract + redeploy
3. If migration fails: emergency exit from problematic contract
4. User funds always recoverable through emergency procedures - native MOCA stakes and USD8 balances can both be recovered

### Scenario 4: Native MOCA Transfer Failures
1. Verifier's assetManagerAddress is a contract without receive/fallback
2. `unstakeMoca()` automatically wraps to wMOCA and transfers
3. Verifier receives wMOCA instead of native MOCA
4. Verifier can unwrap wMOCA to native MOCA if needed

---

## View Functions

### Entity Retrieval
- `getIssuer(bytes32 issuerId)` - Returns complete Issuer struct
- `getVerifier(bytes32 verifierId)` - Returns complete Verifier struct  
- `getSchema(bytes32 schemaId)` - Returns complete Schema struct

### Nonce Queries
- `getVerifierNonce(address signerAddress, address userAddress)` - Returns signature nonce for verification
- `getCallerNonce(address caller, DataTypes.EntityType entityType)` - Returns creation nonce for entity type

### Subsidy Information
- `getEligibleSubsidyPercentage(uint256 mocaStaked)` - Returns subsidy percentage for staked amount
- `getAllSubsidyTiers()` - Returns array of all 10 subsidy tiers
- `getSubsidyTier(uint256 tierIndex)` - Returns specific tier (0-9)
- `getEpochPoolSubsidies(uint256 epoch, bytes32 poolId)` - Returns total subsidies for pool in epoch
- `getEpochPoolVerifierSubsidies(uint256 epoch, bytes32 poolId, bytes32 verifierId)` - Returns verifier's subsidies for pool in epoch
- `getVerifierAndPoolAccruedSubsidies(uint256 epoch, bytes32 poolId, bytes32 verifierId, address caller)` - **Called by VotingController** for subsidy claims; validates caller is verifier's asset manager

### Fee Tracking
- `getEpochPoolFeesAccrued(uint256 epoch, bytes32 poolId)` - Returns protocol and voter fees for pool in epoch
- `getEpochFeesAccrued(uint256 epoch)` - Returns total protocol and voter fees for epoch

---

# Others

## Coverage

```bash
╭---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------╮
| File                                                          | % Lines            | % Statements       | % Branches      | % Funcs          |
+==============================================================================================================================================+
| src/EscrowedMoca.sol                                          | 98.91% (182/184)   | 98.40% (185/188)   | 13.89% (15/108) | 100.00% (19/19)  |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| src/IssuerStakingController.sol                               | 98.04% (100/102)   | 97.09% (100/103)   | 7.02% (4/57)    | 100.00% (12/12)  |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| src/LowLevelWMoca.sol                                         | 83.33% (5/6)       | 80.00% (4/5)       | 100.00% (1/1)   | 100.00% (1/1)    |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| src/PaymentsController.sol                                    | 97.42% (415/426)   | 97.32% (400/411)   | 12.82% (25/195) | 100.00% (55/55)  |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| src/libraries/EpochMath.sol                                   | 33.33% (6/18)      | 36.84% (7/19)      | 100.00% (0/0)   | 33.33% (3/9)     |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/1. IssuerStakingController/IssuerStakingController.t.sol | 77.36% (41/53)     | 71.43% (30/42)     | 100.00% (0/0)   | 100.00% (12/12)  |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/1. IssuerStakingController/TransferGasLimitChanged.t.sol | 75.00% (3/4)       | 66.67% (2/3)       | 100.00% (0/0)   | 100.00% (1/1)    |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/2. PaymentsController/PaymentsController.t.sol           | 85.63% (143/167)   | 84.52% (131/155)   | 100.00% (0/0)   | 100.00% (24/24)  |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/2. PaymentsController/SetPaymentsController.t.sol        | 50.00% (1/2)       | 0.00% (0/1)        | 100.00% (0/0)   | 100.00% (1/1)    |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/2. PaymentsController/TransferGasLimitChanged.t.sol      | 75.00% (3/4)       | 66.67% (2/3)       | 100.00% (0/0)   | 100.00% (1/1)    |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/3. EscrowedMoca/AllPenaltiesToTreasury.t.sol             | 80.00% (4/5)       | 75.00% (3/4)       | 100.00% (0/0)   | 100.00% (1/1)    |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/3. EscrowedMoca/EscrowedMoca.t.sol                       | 83.95% (68/81)     | 82.19% (60/73)     | 100.00% (0/0)   | 100.00% (12/12)  |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/utils/MockUSD8.sol                                       | 33.33% (2/6)       | 33.33% (1/3)       | 100.00% (0/0)   | 33.33% (1/3)     |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/utils/MockWMoca.sol                                      | 44.44% (12/27)     | 47.83% (11/23)     | 0.00% (0/7)     | 42.86% (3/7)     |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| test/utils/TestingHarness.sol                                 | 91.94% (57/62)     | 94.81% (73/77)     | 100.00% (0/0)   | 90.00% (9/10)    |
|---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------|
| Total                                                         | 90.85% (1042/1147) | 90.90% (1009/1110) | 12.23% (45/368) | 92.26% (155/168) |
╰---------------------------------------------------------------+--------------------+--------------------+-----------------+------------------╯
```

- yellow lines are on require statements; which would be green had they been if statements
- red lines on hash collision in id generation - where the while loop would execute to increment salt
