# VotingEscrowMoca [veMoca]

## Table of Contents

- [Executive Summary](#executive-summary)
- [Key Innovations](#key-innovations)
- [How It Works](#how-it-works)
  - [Creating Locks](#creating-locks)
  - [Managing Locks](#managing-locks)
  - [Delegation System](#delegation-system)
- [Technical Architecture](#technical-architecture)
  - [On a lock's liveliness](#on-a-locks-liveliness)
  - [Forward-Decay Mechanism: freezing intra-epoch decay](#forward-decay-mechanism-freezing-intra-epoch-decay)
  - [Design considerations for freezing intra-epoch decay](#design-considerations-for-freezing-intra-epoch-decay)
  - [Handling mid-epoch lock creations](#handling-mid-epoch-lock-creations-in-tandem-w-freezing-intra-epoch-decay)
  - [Quad-Accounting System & Delegation](#quad-accounting-system--delegation)
  - [Forward-Delegation Mechanism](#forward-delegation-mechanism)
  - [Pending Deltas System](#pending-deltas-system)
  - [Locks: Using expiry, instead of duration](#locks-using-expiry-instead-of-duration)
- [Security & Safeguards](#security--safeguards)
  - [Multi-Role Access Control](#multi-role-access-control)
  - [Three-Stage Emergency System](#three-stage-emergency-system)
  - [Built-in Protections](#built-in-protections)
- [Gas Optimizations](#gas-optimizations)
- [Edge Cases Handled](#edge-cases-handled)
- [Mid-epoch created locks - further details](#mid-epoch-created-locks---further-details)
- [Summary](#summary)

## Executive Summary

VotingEscrowMoca (veMoca) is a voting power system that rewards long-term commitment. 
Users lock MOCA or esMOCA tokens to receive non-transferable veMOCA, which grants voting rights in the protocol's governance.
Optimized for fast chains using timestamps, it tracks both personal and delegated activity, ensuring efficient, fair, and real-time voting and reward/subsidy distribution.

**Core Principles:**
- **Time-weighted voting**: More veMOCA for longer lock periods (up to 2 years)
- **Linear decay**: Voting power decreases predictably over time
- **Delegation flexibility**: Lock owners can delegate voting power to registered delegates with forward-delegation mechanism
- **Emergency protection**: Built-in safeguards protect user funds

## Key Innovations

### 1. **Custom balanceOf Function in veToken**

- The veToken contract overrides the standard ERC20 balanceOf to return the current, decayed voting power at the query time. 
- This allows wallets to display accurate, real-time values without off-chain computation, enabling users to observe decay directly in their wallet interfaces.
- Most ve systems require external tools or dApps to calculate decayed balances, making this a user-friendly innovation.

### 2. **Decay Frozen Within an Epoch**

- Voting power decay is paused during an epoch, preventing continuous decay that would force users to rush votes before value drops.
- It promotes deliberate participation without time pressure. 
- However, this does not mean that user' voting power does not decay btw epochs; it simply occurs step-wise. 
- This is unprecedented in ve systems, where decay is kept continuous for simplicity. 

### 3. **Quad-Account Architecture**

Every address has four separate tracking systems:
- **Personal**: Your own locked tokens
- **Delegated**: Voting power others have delegated to you
- **User-Delegate Pairs**: Specific tracking of each user-delegate relationship
- **Global**: Overall system state

This enables:
- Independent voting with personal vs delegated power
- Accurate reward distribution in VotingController
- Clean delegation without affecting personal positions
- Precise tracking of user contributions to delegate rewards

### 4. **Time-Based ve.Bias Calculation via Lock.Expiry** 

- Voting power (bias) is calculated using absolute timestamps from lock.expiry, ensuring all interconnected contracts (e.g., reward distributors, gauges) align with a universal time reference. 
- This avoids discrepancies in multi-contract ecosystems.

### 5. **Forward-Delegation with Pending Deltas**

- Delegation changes take effect in the next epoch (not immediately) to prevent double-voting exploits
- Uses a sophisticated pending deltas system to queue delegation changes
- Allows seamless switching between delegates without gaps in voting power
- Mathematically ensures no voting power is lost or duplicated during transitions

### 6. **Redesign Over Curve's Block Interpolation for Decay** 

Curve's veCRV uses block-based interpolation for decay calculations, approximating time via block numbers assuming consistent block times. 
This is inherently flawed and especially made worse on fast chains.

- For fast L1s and L2s with <1s blocks, (BSC with 3s, Sonic with variable rates), interpolation rounds down aggressively, often flooring balances to 0 prematurely due to granularity issues. 
- Most protocols blindly copy Curve's design without adapting for chain specifics, leading to inaccurate voting power and unfair reward distribution. 
- This contract redesigns from the ground up using pure timestamps for precise, chain-agnostic decay, optimized for high-throughput environments. 

### 7. **Aggregation of Voting Power**

Users benefit from seamless aggregation of voting power across all their locks. 

Instead of managing votes per individual lock, the system automatically sums the voting power from all active locks—regardless of lock type or expiry—using custom balance functions. This means users interact with their total veMOCA balance when voting, without needing to specify or track individual locks.

This aggregation is handled natively in the contract's balance calculations, ensuring that voting, delegation, and reward distribution always reflect the user's full, up-to-date voting power. The approach streamlines participation and reduces complexity, supporting both straightforward and advanced governance strategies.


## How It Works

### Creating Locks

When you lock tokens:
1. Choose amount (MOCA and/or esMOCA) and duration (min current+3 epochs, max 2 years)
2. Receive veMOCA proportional to amount × time
3. Your veMOCA starts decaying linearly toward zero at expiry
4. Optionally delegate to a registered delegate immediately

**Example**: Locking 1000 MOCA for 1 year gives you ~500 veMOCA initially, decaying to 0 over the year.

**Voting Power Calculation**

```bash
slope = lockedAmount / maxLockDuration
bias = slope × expiryTimestamp
currentVotingPower = bias - (slope × currentTime)
```

**Why this formula?**
- Standardizes decay rate across all locks
- Enables efficient global calculations
- Aligns with epoch-based architecture

### Managing Locks

**Increase Amount**: Add more tokens to existing lock without changing expiry
- Requires at least 3 epochs remaining (current + 3 more)
- Prevents ineffective additions that would decay before use

**Extend Duration**: Push expiry further into future
- Must extend to at least 3 epochs from now
- Recalculates veMOCA based on new duration

**Unlock**: Withdraw original tokens after expiry
- Burns all associated veMOCA
- Cannot unlock early (no emergency exits during normal operation)
- Automatically handles cleanup for delegated locks

### Delegation System

Lock owners can delegate voting power to registered delegates:

**Key Features:**
- Delegate individual locks (not partial amounts)
- Change delegates using `switchDelegate` or reclaim power anytime
- Delegation takes effect next epoch (prevents double-voting)
- Delegates must pay registration fee to participate
- Uses pending deltas to queue changes

**Process:**
1. Choose a registered delegate
2. Delegate your lock (schedules veMOCA transfer for next epoch)
3. Delegate votes on your behalf starting next epoch
4. Reclaim anytime by undelegating or switch directly to another delegate

---

# Technical Architecture

## On a lock's liveliness 

In `VotingController`, voting power within an epoch is fixed; there is no intra-epoch decay. 
This allows users to vote at any time during an epoch without rushing. 

This is achieved by benchmarking voting power to the end of said epoch; i.e. everyone gets decayed forward.
Put differently, users vote with the voting power they would have at the end of the Epoch.

**Due to forward-decay and forward-delegation, the minimum meaningful duration of a lock is current + 3 epochs:**

Consider the delegation scenario:
1. Epoch 1: User creates lock
2. Epoch 2: User delegates lock; user still retains voting rights in epoch 2
3. Epoch 3: Delegation takes effect; delegate can now vote with the lock
4. Epoch 4: Lock's voting power is forward-decayed to 0

This minimum requirement stems from two core mechanics:
1. Forward-decay: All locks' voting power is decayed to 0 at epoch end
2. Forward-delegation: Delegation only takes effect in the next epoch

**Thus to prevent ineffective delegations, increases, or extensions where the added value decays to zero before usable in future voting, we implement the following check:**

```solidity
// lock must have at least 4 epochs `liveliness` before expiry: current + 3 more epochs
require(expiry >= currentEpochStart + (4 * EpochMath.EPOCH_DURATION), Errors.LockExpiresTooSoon());
```

This check is found in the following functions:
- createLock
- increaseAmount
- increaseDuration
- delegateLock
- switchDelegate
- undelegateLock

## Forward-Decay Mechanism: freezing intra-epoch decay

**Traditional Systems**: Vote with current voting power (encourages rushing)
**veMOCA**: Vote with power at epoch end (fair for all)

This is achieved by calculating voting power as if the epoch has already ended:

```bash
votingPower = veBalance.bias - veBalance.slope × epochEndTime
```

**Important**: Locks expiring in epoch N have 0 voting power in that epoch, making epoch N-1 their last meaningful voting period.

### Design considerations for freezing intra-epoch decay

**Option 1: voting power fixed within an epoch by referencing `veMoca.balanceOfAt(currenEpochStart)`**
- regardless of when users vote during an epoch, their voting power is unchanged and benchmarked to their voting power at the *start of epoch*.

**Option 2: voting power fixed by referencing `veMoca.balanceOfAt(endOfCurrentEpoch)`**
- apply the entire epoch's decay to everyone; i.e. forward-decay benchmarking 
- to that end "freezing" is a misnomer, but we'll live with it 

### Handling mid-epoch lock creations [in tandem w/ freezing intra-epoch decay]

**Option 1: voting power fixed within an epoch by referencing `veMoca.balanceOfAt(currenEpochStart)`**
- under this implementation option, a mid-epoch lock's voting power will be inflated
- because we are back-dating its voting power, from creation time, which would lower its bias offset
- this is the same bias offset that keeps voting power accurate by applying decay from T0 to now.

### We can solve this by making numerous changes to the system, centred around forward-booking lock creations

To solve this, update `_createLockFor` to book new locks to `userHistory[user][nextEpochStart]`, ensuring mid-epoch locks only affect the next epoch.
- **this means mid-epoch created locks can only vote next epoch**
- when voting in the next epoch, there wil be decay arising from timeDelta btw creationTime and nextEpochStart.
- e.g. lock created 15 Jan. can vote on 1 Feb[new epoch], decay from 15 Jan - 30 Jan applied. 

A minor issue of note: in the first epoch, no voting can be done, since any locks created are forward-booked. 
Therefore, the first epoch of rewards are forgone.

> *Additionally, booking a lock to nextEpochStart could require other non-obvious changes*

**Option 2: voting power fixed by referencing `veMoca.balanceOfAt(endOfCurrentEpoch)`**
- under this implementation option, a mid-epoch lock's voting power will be forward decayed, like every other lock 
- forward-decay benchmarking is consistently applied to all locks
- crucially this allows mid-epoch created locks to vote immediately in the same epoch; they need not wait for the next epoch.

**Conclusion: We will implement Option 2**

It greatly improves user experience, and requires lesser changes and introduces fewer complexities. 
Additionally, in the first epoch, locks created allow immediate voting and user participation [unlike option 1].

*The only notable downside is that, on the final epoch:*
- Users would have a non-zero number of votes at epoch start.
- But due to the forward-decay benchmarking, they would not be able to vote, since its zero-ed out

This is acceptable.

### Quad-Accounting System & Delegation

The contract maintains four separate tracking systems:

```
1. Global State → totalSupplyAt → Total System veMOCA
2. Personal Locks → userHistory → Personal Voting Power
3. Delegated Locks → delegateHistory → Delegated Voting Power  
4. User-Delegate Pairs → delegatedAggregationHistory → Specific Contributions
```

**The Two Parallel Streams:**

**Stream A: The Aggregate Stream (Global Account State)**
- Purpose: Tracks the total voting power of an account (User or Delegate) for voting and total supply calculations
- Mappings: `userHistory`, `delegateHistory`, `slopeChanges`, `userSlopeChanges`, `userPendingDeltas`
- Used By: `balanceOf()`, `totalSupply()`, and `_viewAccountAndGlobalAndPendingDeltas`

**Stream B: The Parallel Stream (Pair-Specific State)**
- Purpose: Tracks specifically how much voting power User A has contributed to Delegate B
- Mappings: `delegatedAggregationHistory`, `userDelegatedSlopeChanges`, `userPendingDeltasForDelegate`
- Used By: `getSpecificDelegatedBalanceAtEpochEnd` (for calculating the user's share of a delegate's rewards)

This separation enables:
- Independent voting with personal vs delegated power
- Accurate reward distribution in VotingController
- Clean delegation without affecting personal positions
- Precise tracking for reward calculations

## Forward-Delegation Mechanism

Delegation changes take effect in the next epoch to prevent double-voting exploits:

```solidity
// When delegating a lock:
// 1. Lock's voting power is scheduled to be removed from user in next epoch
userPendingDeltas[user][nextEpochStart].hasSubtraction = true;
userPendingDeltas[user][nextEpochStart].subtractions = lockVeBalance;

// 2. Lock's voting power is scheduled to be added to delegate in next epoch
delegatePendingDeltas[delegate][nextEpochStart].hasAddition = true;
delegatePendingDeltas[delegate][nextEpochStart].additions = lockVeBalance;

// 3. User-delegate pair tracking is also updated
userPendingDeltasForDelegate[user][delegate][nextEpochStart].hasAddition = true;
userPendingDeltasForDelegate[user][delegate][nextEpochStart].additions = lockVeBalance;
```

This ensures:
- No double voting in the current epoch
- Seamless transition of voting power
- Mathematical consistency across all operations

## Pending Deltas System

The pending deltas system manages future state changes:

```solidity
struct VeDeltas {
    VeBalance additions;      // veMOCA to be added
    VeBalance subtractions;   // veMOCA to be removed
    bool hasAddition;        // Flag for additions
    bool hasSubtraction;     // Flag for subtractions
}
```

During state updates, pending deltas are applied:
1. Decay is applied first (via slope changes)
2. Additions are applied
3. Subtractions are applied
4. Deltas are cleared after application

This allows complex operations like:
- Undelegating then redelegating in same epoch (changes cancel out)
- Switching delegates directly (atomic operation)
- Multiple delegation changes queued for different epochs

### Locks: Using expiry, instead of duration

When calculating bias, we use expiry [an absolute timestamp] instead of duration:

- `slope = amount / MAXTIME` 
- `bias  = slope * expiryTimestamp`

This forms the veBalance:`{bias, slope}`, as if the lock started at t=0 (Unix epoch), yielding an inflated bias.

But we query the voting power via: `veBalance.bias - veBalance.slope * currentTimestamp`
alternatively expressed: `votingPower = bias - slope × currentTimestamp`

This subtraction correctly offsets the period before the lock began, ensuring accurate decay from the actual lock start time.

#### Why this is an improvement 

**Better efficiency, less storage, and lower gas costs**

1. Stores less data (no need to record start time)
2. Makes vote decay and veToken queries lightweight and efficient 
3. Easy global/user aggregations (sum biases/slopes) and scheduled changes (e.g., slopeChanges[expiry]), avoiding start-time storage/queries.
4. Lock's veBalance remains constant regardless of when it's calculated


# Security & Safeguards

## Multi-Role Access Control
- **Monitor**: Can pause during emergencies
- **Global Admin**: Can unpause and freeze
- **Emergency Handler**: Can return funds when frozen
- **Voting Controller**: Manages delegate registration
- **Cron Job**: Can create locks for multiple users

## Three-Stage Emergency System
1. **Pause**: Stops all operations (reversible)
2. **Freeze**: Permanent shutdown (one-way)
3. **Emergency Exit**: Returns all locked tokens to users

## Built-in Protections
- Minimum lock amounts prevent dust attacks (1e13 wei minimum)
- 4-epoch minimum for operations ensures effectiveness
- Forward-booking prevents double-voting exploits
- Non-transferable veMOCA prevents gaming
- Gas limit controls for MOCA transfers

# Gas Optimizations

1. **Checkpoint Compression**: Same-epoch updates overwrite instead of append
2. **Batch Processing**: Epoch alignment enables efficient loops
3. **Storage Efficiency**: Uses VeBalance struct (bias + slope) instead of storing amounts
4. **Unchecked Arithmetic**: Safe unchecked blocks for epoch advancement
5. **Lazy Evaluation**: Voting power decays automatically without manual updates

# Edge Cases Handled

**Mid-Epoch Lock Creation**: 
- Locks created mid-epoch can vote immediately
- Forward-decay ensures fair voting power

**Final Epoch Problem**:
- Locks have non-zero veMOCA at epoch start
- Forward-decay shows 0 voting power (intended behavior)
- Last usable epoch is always N-1

**Expired Delegations**:
- Users can always reclaim expired locks
- No requirement for delegate to remain registered
- Automatic cleanup via lazy evaluation

**Delegation State Transitions**:
- Undelegate + Delegate in same epoch = Switch (mathematically identical)
- Direct switching via `switchDelegate` function
- No gaps in voting power during transitions

## Mid-epoch created locks - further details

Consider 2 identical locks, identical amount and same expiry time [lock A and lock B]

- lockA is created mid-way in Epoch 1 at 15th day.
- lockB is created 5 days after lockA; still within Epoch 1.

**Would they have the exact same veBalances?**
- Yes

```markdown
    The slope is derived as principal / MAX_LOCK_DURATION.
    The bias is derived as slope * expiry.
    Neither the bias nor the slope depends on the lock's creation timestamp—only on the principal and expiry (which are identical for both locks).

    The mid-epoch creation times (day 15 vs. day 20) do not affect the VeBalance struct, as the system does not store or factor in a creation timestamp for veBalance calculations. 
    The earlier creation of lock A means it provided voting power for those extra 5 days, but from lock B's creation onward, both locks yield identical voting power at any given time (bias - slope * t), consistent with the identical structs.

    Their voting power would not differ in epoch 2 (or any subsequent epoch). The difference in creation time does not result in a difference in the decay applied, as the veBalance for each lock (bias and slope) is derived solely from the principal amount and the absolute expiry timestamp—neither of which incorporates the creation timestamp. Consequently, at any given evaluation point (e.g., the end of epoch 2, as used for voting power benchmarking in the VotingController contract), both locks yield identical voting power values.
```

---

# Summary

**Note**: This system prioritizes fairness and security over flexibility. 
- Early unlocks are not possible, and all time commitments must be honored. 
- In exchange, users gain a transparent, manipulation-resistant voting system with built-in emergency protections.

Key improvements in veMoca V2:
- Enhanced delegation system with forward-booking
- Quad-accounting for precise reward distribution
- Pending deltas for seamless state transitions
- Gas optimizations with unchecked arithmetic
- Improved minimum lock duration requirements
- Direct delegate switching functionality