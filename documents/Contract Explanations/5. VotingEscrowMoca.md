# VotingEscrowMoca [veMoca]

## Table of Contents

- [Executive Summary](#executive-summary)
- [Key Innovations](#key-innovations)
- [How It Works](#how-it-works)
  - [Creating Locks](#creating-locks)
  - [Managing Locks](#managing-locks)
  - [Delegation System](#delegation-system)
- [Technical Architecture](#technical-architecture)
  - [On a lock's liveliness](#on-a-locks-liveliness)
  - [Forward-Decay Mechanism: freezing intra-epoch decay](#forward-decay-mechanism-freezing-intra-epoch-decay)
  - [Design considerations for freezing intra-epoch decay](#design-considerations-for-freezing-intra-epoch-decay)
  - [Handling mid-epoch lock creations](#handling-mid-epoch-lock-creations-in-tandem-w-freezing-intra-epoch-decay)
  - [Dual-Accounting System & Delegation](#dual-accounting-system--delegation)
  - [Locks: Using expiry, instead of duration](#locks-using-expiry-instead-of-duration)
- [Security & Safeguards](#security--safeguards)
  - [Multi-Role Access Control](#multi-role-access-control)
  - [Three-Stage Emergency System](#three-stage-emergency-system)
  - [Built-in Protections](#built-in-protections)
- [Gas Optimizations](#gas-optimizations)
- [Edge Cases Handled](#edge-cases-handled)
- [Mid-epoch created locks - further details](#mid-epoch-created-locks---further-details)
- [Summary](#summary)

## Executive Summary

VotingEscrowMoca (veMoca) is a voting power system that rewards long-term commitment. 
Users lock MOCA or esMOCA tokens to receive non-transferable veMOCA, which grants voting rights in the protocol's governance.
Optimized for fast chains using timestamps, it tracks both personal and delegated activity, ensuring efficient, fair, and real-time voting and reward/subsidy distribution.

**Core Principles:**
- **Time-weighted voting**: More veMOCA for longer lock periods (up to 2 years)
- **Linear decay**: Voting power decreases predictably over time
- **Delegation flexibility**: Lock owners can delegate voting power to arbitrarily to multiple active delegates
- **Emergency protection**: Built-in safeguards protect user funds

## Key Innovations

### 1. **Custom balanceOf Function in veToken**

- The veToken contract overrides the standard ERC20 balanceOf to return the current, decayed voting power at the query time. 
- This allows wallets to display accurate, real-time values without off-chain computation, enabling users to observe decay directly in their wallet interfaces.
- Most ve systems require external tools or dApps to calculate decayed balances, making this a user-friendly innovation.

### 2. **Decay Frozen Within an Epoch**

- Voting power decay is paused during an epoch, preventing continuous decay that would force users to rush votes before value drops.
- It promotes deliberate participation without time pressure. 
- However, this does not mean that user' voting power does not decay btw epochs; it simply occurs step-wise. 
- This is unprecedented in ve systems, where decay is kept continuous for simplicity. 

### 3. **Dual-Account Architecture**

Every address has two separate "pockets":
- **Personal**: Your own locked tokens
- **Delegated**: Voting power others have delegated to you

Delegates can exercise voting rights using both their personal voting power and any voting power delegated to them, each tracked separately.
This allows seamless switching between roles without separate contracts or addresses.

Unique because most systems use single-account models or require explicit delegate contracts, limiting flexibility. This enables advanced strategies like partial delegation.

### 4. **Time-Based ve.Bias Calculation via Lock.Expiry** 

- Voting power (bias) is calculated using absolute timestamps from lock.expiry, ensuring all interconnected contracts (e.g., reward distributors, gauges) align with a universal time reference. 
- This avoids discrepancies in multi-contract ecosystems.

### 5. **Redesign Over Curve's Block Interpolation for Decay** 

Curve's veCRV uses block-based interpolation for decay calculations, approximating time via block numbers assuming consistent block times. 
This is inherently flawed and especially made worse on fast chains.

- For fast L1s and L2s with <1s blocks, (BSC with 3s, Sonic with variable rates), interpolation rounds down aggressively, often flooring balances to 0 prematurely due to granularity issues. 
- Most protocols blindly copy Curve's design without adapting for chain specifics, leading to inaccurate voting power and unfair reward distribution. 
- This contract redesigns from the ground up using pure timestamps for precise, chain-agnostic decay, optimized for high-throughput environments. 

### 6. **Aggregation of Voting Power**

Users benefit from seamless aggregation of voting power across all their locks. 

Instead of managing votes per individual lock, the system automatically sums the voting power from all active locks—regardless of lock type or expiry—using custom balance functions. This means users interact with their total veMOCA balance when voting, without needing to specify or track individual locks.

This aggregation is handled natively in the contract’s balance calculations, ensuring that voting, delegation, and reward distribution always reflect the user’s full, up-to-date voting power. The approach streamlines participation and reduces complexity, supporting both straightforward and advanced governance strategies.


## How It Works

### Creating Locks

When you lock tokens:
1. Choose amount (MOCA and/or esMOCA) and duration (min 2 epochs, max 2 years)
2. Receive veMOCA proportional to amount × time
3. Your veMOCA starts decaying linearly toward zero at expiry

**Example**: Locking 1000 MOCA for 1 year gives you ~500 veMOCA initially, decaying to 0 over the year.

**Voting Power Calculation**

```bash
slope = lockedAmount / maxLockDuration
bias = slope × expiryTimestamp
currentVotingPower = bias - (slope × currentTime)
```

**Why this formula?**
- Standardizes decay rate across all locks
- Enables efficient global calculations
- Aligns with epoch-based architecture

### Managing Locks

**Increase Amount**: Add more tokens to existing lock without changing expiry
- Requires at least 2 epochs remaining
- Prevents ineffective additions that would decay before use

**Extend Duration**: Push expiry further into future
- Must extend to at least 2 epochs from now
- Recalculates veMOCA based on new duration

**Unlock**: Withdraw original tokens after expiry
- Burns all associated veMOCA
- Cannot unlock early (no emergency exits during normal operation)

### Delegation System

Lock owners can delegate voting power to registered delegates:

**Key Features:**
- Delegate individual locks (not partial amounts)
- Change delegates or reclaim power anytime
- Delegation takes effect next epoch (prevents double-voting)
- Delegates must pay registration fee to participate

**Process:**
1. Choose a registered delegate
2. Delegate your lock (transfers veMOCA to delegate)
3. Delegate votes on your behalf
4. Reclaim anytime by undelegating

---

# Technical Architecture

## On a lock's liveliness 

In `VotingController`, voting power within an epoch is fixed; there is no intra-epoch decay. 
This allows users to vote at any time during an epoch without rushing. 

This is achieved by benchmarking voting power to the end of said epoch; i.e. everyone gets decayed forward.
Put differently, users vote with the voting power they would have at the end of the Epoch.

**Due to forward-decay, the last meaningful epoch of a lock is one less than its actual:**

- Assume a lock ends at epoch N; it would have 0 veMoca at the end of epoch N. (would have non-zero veMoca at start of epoch N)
- It cannot vote in epoch N, since per `VotingController`, it has 0 votes [forward-decay].
- It can vote last in Epoch N-1, where it would have a non-zero bias for that epochEnd.

This means that the last meaningful voting epoch of a lock is `N-1` [where N is its final epoch].

**Thus to prevents ineffective delegations, increases, or extensions where the added value decays to zero before usable in future voting, we implement the following check:**

```solidity
            // must have at least 2 Epoch left to increase amount: to meaningfully vote for the next epoch  
            // this is a result of VotingController.sol's forward-decay: benchmarking voting power to the end of the epoch       
            require(oldLock.expiry > EpochMath.getEpochEndTimestamp(EpochMath.getCurrentEpochNumber() + 1), "Lock expires too soon");
```

This check (in some variation) is found in the following functions:
- _createLockFor
- increaseAmount
- increaseDuration
- delegateLock
- switchDelegate

## Forward-Decay Mechanism: freezing intra-epoch decay

**Traditional Systems**: Vote with current voting power (encourages rushing)
**veMOCA**: Vote with power at epoch end (fair for all)

This is achieved by calculating voting power as if the epoch has already ended:

```bash
votingPower = veBalance.bias - veBalance.slope × epochEndTime
```

**Important**: Locks expiring in epoch N have 0 voting power in that epoch, making epoch N-1 their last meaningful voting period.

### Design considerations for freezing intra-epoch decay

**Option 1: voting power fixed within an epoch by referencing `veMoca.balanceOfAt(currenEpochStart)`**
- regardless of when users vote during an epoch, their voting power is unchanged and benchmarked to their voting power at the *start of epoch*.

**Option 2: voting power fixed by referencing `veMoca.balanceOfAt(endOfCurrentEpoch)`**
- apply the entire epoch's decay to everyone; i.e. forward-decay benchmarking 
- to that end "freezing" is a misnomer, but we'll live with it 

### Handling mid-epoch lock creations [in tandem w/ freezing intra-epoch decay]

**Option 1: voting power fixed within an epoch by referencing `veMoca.balanceOfAt(currenEpochStart)`**
- under this implementation option, a mid-epoch lock's voting power will be inflated
- because we are back-dating its voting power, from creation time, which would lower its bias offset
- this is the same bias offset that keeps voting power accurate by applying decay from T0 to now.

### We can solve this by making numerous changes to the system, centred around forward-booking lock creations

To solve this, update `_createLockFor` to book new locks to `userHistory[user][nextEpochStart]`, ensuring mid-epoch locks only affect the next epoch.
- **this means mid-epoch created locks can only vote next epoch**
- when voting in the next epoch, there wil be decay arising from timeDelta btw creationTime and nextEpochStart.
- e.g. lock created 15 Jan. can vote on 1 Feb[new epoch], decay from 15 Jan - 30 Jan applied. 

A minor issue of note: in the first epoch, not voting can be done, since any locks created are forward-booked. 
Therefore, the first epoch of rewards are forgone.

> *Additionally, booking a lock to nextEpochStart could require other non-obvious changes*

**Option 2: voting power fixed by referencing `veMoca.balanceOfAt(endOfCurrentEpoch)`**
- under this implementation option, a mid-epoch lock's voting power will be forward decayed, like every other lock 
- forward-decay benchmarking is consistently applied to all locks
- crucially this allows mid-epoch created locks to vote immediately in the same epoch; they need not wait for the next epoch.

**Conclusion: We will implement Option 2**

It greatly improves user experience, and requires lesser changes and introduces fewer complexities. 
Additionally, in the first epoch, locks created allow immediate voting and user participation [unlike option 1].

*The only notable downside is that, on the final epoch:*
- Users would have a non-zero number of votes at epoch start.
- But due to the forward-decay benchmarking, they would not be able to vote, since its zero-ed out

This is acceptable.

### Dual-Accounting System & Delegation

The contract maintains separate tracking for personal and delegated voting power:

```
Personal Locks → userHistory → Personal Voting Power
    ↓ (delegate)
Delegated Locks → delegateHistory → Delegated Voting Power
```

- Users can delegate individual locks to another address (delegate)
- This is to allow delegated voting, which will be handled by `VotingController.sol`
- Target Delegate must be registered through `VotingController.sol`, as there is a registration fee to be paid.
- Delegated voting power is tracked per lock and per delegate, and can be re-delegated or revoked by the lock owner.

The dual-accounting system works via the following mappings:

**Tracking personal locks**
```solidity
    // user personal data: perEpoch | perPoolPerEpoch
    mapping(address user => mapping(uint256 eTime => uint256 slopeChange)) public userSlopeChanges;
    mapping(address user => mapping(uint256 eTime => DataTypes.VeBalance veBalance)) public userHistory; // aggregated user veBalance
    mapping(address user => uint256 lastUpdatedTimestamp) public userLastUpdatedTimestamp;
```

**Tracking delegated locks**
```solidity
    // delegation data
    mapping(address delegate => bool isRegistered) public isRegisteredDelegate;                             // note: payment to treasury
    mapping(address delegate => mapping(uint256 eTime => uint256 slopeChange)) public delegateSlopeChanges;
    mapping(address delegate => mapping(uint256 eTime => DataTypes.VeBalance veBalance)) public delegateHistory; // aggregated delegate veBalance
    mapping(address delegate => uint256 lastUpdatedTimestamp) public delegateLastUpdatedTimestamp;
```

**This separation enables:**
- Independent voting with personal vs delegated power
- Accurate reward distribution in VotingController
- Clean delegation without affecting personal positions


### Locks: Using expiry, instead of duration

When calculating bias, we use expiry [an absolute timestamp] instead of duration:

- `slope = amount / MAXTIME` 
- `bias  = slope * expiryTimestamp`

This forms the veBalance:`{bias, slope}`, as if the lock started at t=0 (Unix epoch), yielding an inflated bias.

But we query the voting power via: `veBalance.bias - veBalance.slope * currentTimestamp`
alternatively expressed: `votingPower = bias - slope × currentTimestamp`

This subtraction correctly offsets the period before the lock began, ensuring accurate decay from the actual lock start time.

#### Why this is an improvement 

**Better efficiency, less storage, and lower gas costs**

1. Stores less data (no need to record start time)
2. Makes vote decay and veToken queries lightweight and efficient 
3. Easy global/user aggregations (sum biases/slopes) and scheduled changes (e.g., slopeChanges[expiry]), avoiding start-time storage/queries.


# Security & Safeguards

## Multi-Role Access Control
- **Monitor**: Can pause during emergencies
- **Global Admin**: Can unpause and freeze
- **Emergency Handler**: Can return funds when frozen
- **Voting Controller**: Manages delegate registration

## Three-Stage Emergency System
1. **Pause**: Stops all operations (reversible)
2. **Freeze**: Permanent shutdown (one-way)
3. **Emergency Exit**: Returns all locked tokens to users

## Built-in Protections
- Minimum lock amounts prevent dust attacks
- 2-epoch minimum for operations ensures effectiveness
- Forward-booking prevents double-voting exploits
- Non-transferable veMOCA prevents gaming

# Gas Optimizations

1. **Checkpoint Compression**: Same-epoch updates overwrite instead of append
2. **Batch Processing**: Epoch alignment enables efficient loops
3. **Storage Efficiency**: Uses VeBalance struct (bias + slope) instead of storing amounts

# Edge Cases Handled

**Mid-Epoch Lock Creation**: 
- Locks created mid-epoch can vote immediately
- Forward-decay ensures fair voting power

**Final Epoch Problem**:
- Locks have non-zero veMOCA at epoch start
- Forward-decay shows 0 voting power (intended behavior)
- Last usable epoch is always N-1

**Expired Delegations**:
- Users can always reclaim expired locks
- No requirement for delegate to remain registered

## Mid-epoch created locks - further details

Consider 2 identical locks, identical amount and same expiry time [lock A and lock B]

- lockA is created mid-way in Epoch 1 at 15th day.
- lockB is created 5 days after lockA; still within Epoch 1.

**Would they have the exact same veBalances?**
- Yes

```markdown
    The slope is derived as principal / MAX_LOCK_DURATION.
    The bias is derived as slope * expiry.
    Neither the bias nor the slope depends on the lock's creation timestamp—only on the principal and expiry (which are identical for both locks).

    The mid-epoch creation times (day 15 vs. day 20) do not affect the VeBalance struct, as the system does not store or factor in a creation timestamp for veBalance calculations. 
    The earlier creation of lock A means it provided voting power for those extra 5 days, but from lock B's creation onward, both locks yield identical voting power at any given time (bias - slope * t), consistent with the identical structs.

    Their voting power would not differ in epoch 2 (or any subsequent epoch). The difference in creation time does not result in a difference in the decay applied, as the veBalance for each lock (bias and slope) is derived solely from the principal amount and the absolute expiry timestamp—neither of which incorporates the creation timestamp. Consequently, at any given evaluation point (e.g., the end of epoch 2, as used for voting power benchmarking in the VotingController contract), both locks yield identical voting power values.
```

---

# Summary

**Note**: This system prioritizes fairness and security over flexibility. 
- Early unlocks are not possible, and all time commitments must be honored. 
- In exchange, users gain a transparent, manipulation-resistant voting system with built-in emergency protections.