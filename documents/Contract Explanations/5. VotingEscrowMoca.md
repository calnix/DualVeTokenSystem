# VotingEscrowMoca V2 [veMocaV2]

## Table of Contents

- [Executive Summary](#executive-summary)
- [Key Innovations](#key-innovations)
- [How It Works](#how-it-works)
  - [Creating Locks](#creating-locks)
  - [Managing Locks](#managing-locks)
  - [Delegation System](#delegation-system)
- [Technical Architecture](#technical-architecture)
  - [On a lock's liveliness](#on-a-locks-liveliness)
  - [Forward-Decay Mechanism: freezing intra-epoch decay](#forward-decay-mechanism-freezing-intra-epoch-decay)
  - [Design considerations for freezing intra-epoch decay](#design-considerations-for-freezing-intra-epoch-decay)
  - [Handling mid-epoch lock creations](#handling-mid-epoch-lock-creations-in-tandem-w-freezing-intra-epoch-decay)
  - [Quad-Accounting System & Delegation](#quad-accounting-system--delegation)
  - [Forward-Delegation Mechanism](#forward-delegation-mechanism)
  - [Pending Deltas System](#pending-deltas-system)
  - [Locks: Using expiry, instead of duration](#locks-using-expiry-instead-of-duration)
- [Security & Safeguards](#security--safeguards)
  - [Multi-Role Access Control](#multi-role-access-control)
  - [Three-Stage Emergency System](#three-stage-emergency-system)
  - [Built-in Protections](#built-in-protections)
- [Gas Optimizations](#gas-optimizations)
- [Batch Operations](#batch-operations)
- [Edge Cases Handled](#edge-cases-handled)
- [Mid-epoch created locks - further details](#mid-epoch-created-locks---further-details)
- [Summary](#summary)

## Executive Summary

VotingEscrowMoca V2 (veMoca2) is a voting power system that rewards long-term commitment. 
Users lock MOCA (sent as ETH which gets wrapped as wMOCA) and/or esMOCA tokens to receive non-transferable veMOCA, which grants voting rights in the protocol's governance.
Optimized for fast chains using timestamps, it tracks both personal and delegated activity, ensuring efficient, fair, and real-time voting and reward/subsidy distribution.

**Core Principles:**
- **Time-weighted voting**: More veMOCA for longer lock periods (up to 728 days / ~2 years)
- **Linear decay**: Voting power decreases predictably over time
- **Delegation flexibility**: Lock owners can delegate voting power to registered delegates with forward-delegation mechanism
- **Emergency protection**: Three-stage emergency system protects user funds
- **Epoch-based accounting**: 14-day epochs with decay frozen within epochs for fair participation

## Key Innovations

### 1. **View Functions for veToken Balance Queries**

- The contract provides specialized view functions (`balanceOfAt`, `balanceAtEpochEnd`, `totalSupplyAtTimestamp`) to query decayed voting power at specific timestamps
- These functions simulate the decay calculations without requiring state updates, enabling efficient off-chain queries
- Wallets and dApps can display accurate, real-time voting power using these view functions

### 2. **Decay Frozen Within an Epoch**

- Voting power decay is paused during an epoch, preventing continuous decay that would force users to rush votes before value drops
- It promotes deliberate participation without time pressure
- However, this does not mean that users' voting power does not decay between epochs; it simply occurs step-wise
- This is unprecedented in ve systems, where decay is kept continuous for simplicity

### 3. **Quad-Account Architecture**

Every address has four separate tracking systems:
- **Personal**: Your own locked tokens
- **Delegated**: Voting power others have delegated to you
- **User-Delegate Pairs**: Specific tracking of each user-delegate relationship
- **Global**: Overall system state

This enables:
- Independent voting with personal vs delegated power
- Accurate reward distribution in VotingController
- Clean delegation without affecting personal positions
- Precise tracking of user contributions to delegate rewards

### 4. **Time-Based ve.Bias Calculation via Lock.Expiry** 

- Voting power (bias) is calculated using absolute timestamps from lock.expiry, ensuring all interconnected contracts (e.g., reward distributors, gauges) align with a universal time reference
- This avoids discrepancies in multi-contract ecosystems

### 5. **Forward-Delegation with Pending Deltas**

- Delegation changes take effect in the next epoch (not immediately) to prevent double-voting exploits
- Uses a sophisticated pending deltas system to queue delegation changes
- Allows seamless switching between delegates without gaps in voting power
- Mathematically ensures no voting power is lost or duplicated during transitions

### 6. **Redesign Over Curve's Block Interpolation for Decay** 

Curve's veCRV uses block-based interpolation for decay calculations, approximating time via block numbers assuming consistent block times. 
This is inherently flawed and especially made worse on fast chains.

- For fast L1s and L2s with <1s blocks, (BSC with 3s, Sonic with variable rates), interpolation rounds down aggressively, often flooring balances to 0 prematurely due to granularity issues
- Most protocols blindly copy Curve's design without adapting for chain specifics, leading to inaccurate voting power and unfair reward distribution
- This contract redesigns from the ground up using pure timestamps for precise, chain-agnostic decay, optimized for high-throughput environments

### 7. **Aggregation of Voting Power**

Users benefit from seamless aggregation of voting power across all their locks. 

Instead of managing votes per individual lock, the system automatically sums the voting power from all active locks—regardless of lock type or expiry—using the view functions. This means users interact with their total veMOCA balance when voting, without needing to specify or track individual locks.

This aggregation is handled natively in the contract's balance calculations, ensuring that voting, delegation, and reward distribution always reflect the user's full, up-to-date voting power. The approach streamlines participation and reduces complexity, supporting both straightforward and advanced governance strategies.

## How It Works

### Creating Locks

When you lock tokens:
1. Send ETH (automatically wrapped as wMOCA) and/or provide esMOCA tokens
2. Choose expiry time (min 3 epochs, max 728 days) - must align with epoch boundaries
3. Lock must have at least 3 epochs "liveliness" (current epoch + 2 more epochs)
4. Receive veMOCA proportional to amount × time remaining
5. Your veMOCA starts decaying linearly toward zero at expiry
6. Optionally delegate to a registered delegate immediately (takes effect next epoch)

**Minimum Lock Requirements:**
- Minimum total amount: 1e13 wei (0.00001 MOCA/esMOCA) - prevents precision loss
- Minimum duration: 42 days (3 epochs)
- Minimum liveliness: 3 epochs from current epoch start
- Expiry must align with epoch boundaries (multiples of 14 days)


**Voting Power Calculation**

```solidity
slope = lockedAmount / MAX_LOCK_DURATION  // MAX_LOCK_DURATION = 728 days
bias = slope × expiryTimestamp
currentVotingPower = bias - (slope × currentTime)
```

**Why this formula?**
- Standardizes decay rate across all locks
- Enables efficient global calculations
- Aligns with epoch-based architecture
- Lock's veBalance remains constant regardless of when calculated

### Managing Locks

**increaseAmount**: Add more MOCA (via ETH) and/or esMOCA to existing lock without changing expiry
- Requires at least 3 epochs remaining from current epoch start
- Prevents ineffective additions that would decay before use
- Payable function for MOCA additions

**increaseDuration**: Extend lock expiry by specified duration
- New expiry must align with epoch boundaries
- Must extend to at least 3 epochs from current epoch
- Maximum 728 days from current timestamp
- Recalculates veMOCA based on new expiry

**unlock**: Withdraw original tokens after expiry
- Returns wMOCA (wrapped if native transfer fails with gas limit) and esMOCA
- Cannot unlock early (no emergency exits during normal operation)
- Marks lock as unlocked
- Automatically handles cleanup for delegated locks
- Updates global, user, and delegate states

### Delegation System

Lock owners can delegate voting power to registered delegates:

**Key Features:**
- Delegate individual locks (not partial amounts)
- Change delegates using `switchDelegate` or reclaim power via `undelegateLock` anytime
- Delegation takes effect next epoch (prevents double-voting)
- Delegates must be registered via VotingController (registration fee required)
- Uses pending deltas to queue changes
- Lock must have at least 3 epochs remaining to delegate/switch/undelegate

**Process:**
1. Choose a registered delegate (checked via `isRegisteredDelegate` mapping)
2. Delegate your lock (schedules veMOCA transfer for next epoch)
3. Delegate votes on your behalf starting next epoch
4. Reclaim anytime by undelegating or switch directly to another delegate
5. Delegation state tracked via `lock.delegate` field

---

# Technical Architecture

## On a lock's liveliness 

In `VotingController`, voting power within an epoch is fixed; there is no intra-epoch decay. 
This allows users to vote at any time during an epoch without rushing. 

This is achieved by benchmarking voting power to the end of said epoch; i.e. everyone gets decayed forward.
Put differently, users vote with the voting power they would have at the end of the Epoch.

**Due to forward-decay and forward-delegation, the minimum meaningful duration of a lock is current + 3 epochs:**

Consider the delegation scenario:
1. Epoch 1: User creates and delegates lock; user retains voting rights in epoch 1
2. Epoch 2: Delegation takes effect; delegate can now vote with the lock
3. Epoch 3: Lock's voting power is forward-decayed to 0

This minimum requirement stems from two core mechanics:
1. Forward-decay: All locks' voting power is benchmarked to epoch end
2. Forward-delegation: Delegation only takes effect in the next epoch

**Thus to prevent ineffective delegations, increases, or extensions where the added value decays to zero before usable in future voting, we implement the following check:**

```solidity
// lock must have at least 3 epochs `liveliness` before expiry: current + 2 more epochs
require(expiry >= currentEpochStart + (3 * EpochMath.EPOCH_DURATION), Errors.LockExpiresTooSoon());
```

This check is found in the following functions:
- createLock
- increaseAmount
- increaseDuration
- delegateLock
- switchDelegate
- undelegateLock

## Forward-Decay Mechanism: freezing intra-epoch decay

**Traditional Systems**: Vote with current voting power (encourages rushing)
**veMOCA**: Vote with power at epoch end (fair for all)

This is achieved by calculating voting power as if the epoch has already ended:

```solidity
votingPower = veBalance.bias - veBalance.slope × epochEndTime
```

**Important**: Locks expiring in epoch N have 0 voting power in that epoch, making epoch N-1 their last meaningful voting period.

**Implementation Detail:**
- Epoch duration: 14 days (EpochMath.EPOCH_DURATION)
- All voting power queries in VotingController use `balanceAtEpochEnd()`
- View function returns voting power benchmarked to epoch end timestamp

### Design considerations for freezing intra-epoch decay

**Option 1: voting power fixed within an epoch by referencing `veMoca.balanceOfAt(currentEpochStart)`**
- regardless of when users vote during an epoch, their voting power is unchanged and benchmarked to their voting power at the *start of epoch*.

**Option 2: voting power fixed by referencing `veMoca.balanceAtEpochEnd(currentEpochStart)`**
- apply the entire epoch's decay to everyone; i.e. forward-decay benchmarking 
- to that end "freezing" is a misnomer, but we'll live with it 

### Handling mid-epoch lock creations [in tandem w/ freezing intra-epoch decay]

**Option 1: voting power fixed within an epoch by referencing `veMoca.balanceOfAt(currentEpochStart)`**
- under this implementation option, a mid-epoch lock's voting power will be inflated
- because we are back-dating its voting power, from creation time, which would lower its bias offset
- this is the same bias offset that keeps voting power accurate by applying decay from T0 to now.

### We can solve this by making numerous changes to the system, centred around forward-booking lock creations

To solve this, update `_createLockFor` to book new locks to `userHistory[user][nextEpochStart]`, ensuring mid-epoch locks only affect the next epoch.
- **this means mid-epoch created locks can only vote next epoch**
- when voting in the next epoch, there wil be decay arising from timeDelta btw creationTime and nextEpochStart.
- e.g. lock created 15 Jan. can vote on 1 Feb[new epoch], decay from 15 Jan - 30 Jan applied. 

A minor issue of note: in the first epoch, no voting can be done, since any locks created are forward-booked. 
Therefore, the first epoch of rewards are forgone.

> *Additionally, booking a lock to nextEpochStart could require other non-obvious changes*

**Option 2: voting power fixed by referencing `veMoca.balanceOfAt(endOfCurrentEpoch)`**
- under this implementation option, a mid-epoch lock's voting power will be forward decayed, like every other lock 
- forward-decay benchmarking is consistently applied to all locks
- crucially this allows mid-epoch created locks to vote immediately in the same epoch; they need not wait for the next epoch.

**Conclusion: We have implemented Option 2**

It greatly improves user experience, and requires lesser changes and introduces fewer complexities. 
Additionally, in the first epoch, locks created allow immediate voting and user participation [unlike option 1].

*The only notable downside is that, on the final epoch:*
- Users would have a non-zero number of votes at epoch start.
- But due to the forward-decay benchmarking, they would not be able to vote, since its zero-ed out

This is acceptable.

### Quad-Accounting System & Delegation

The contract maintains four separate tracking systems:

```
1. Global State → veGlobal → Total System veMOCA
2. Personal Locks → userHistory → Personal Voting Power
3. Delegated Locks → delegateHistory → Delegated Voting Power  
4. User-Delegate Pairs → delegatedAggregationHistory → Specific Contributions
```

**State Variables:**

**Global State:**
- `veGlobal`: Aggregate system veBalance
- `lastUpdatedTimestamp`: Global last update timestamp
- `slopeChanges[expiry]`: Scheduled global slope reductions
- `totalSupplyAt[epochStart]`: Cached total supply per epoch

**User State:**
- `userHistory[user][epochStart]`: User's aggregated veBalance
- `userSlopeChanges[user][expiry]`: Scheduled user slope reductions
- `userLastUpdatedTimestamp[user]`: User's last update timestamp
- `userPendingDeltas[user][epochStart]`: Queued delegation changes

**Delegate State:**
- `delegateHistory[delegate][epochStart]`: Delegate's aggregated veBalance
- `delegateSlopeChanges[delegate][expiry]`: Scheduled delegate slope reductions
- `delegateLastUpdatedTimestamp[delegate]`: Delegate's last update timestamp
- `delegatePendingDeltas[delegate][epochStart]`: Queued delegation changes
- `isRegisteredDelegate[delegate]`: Registration flag

**User-Delegate Pair State:**
- `delegatedAggregationHistory[user][delegate][epochStart]`: User's contribution to delegate
- `userDelegatedSlopeChanges[user][delegate][expiry]`: Pair-specific slope changes
- `userPendingDeltasForDelegate[user][delegate][epochStart]`: Pair-specific pending deltas
- `userDelegatedPairLastUpdatedTimestamp[user][delegate]`: Pair last update timestamp

**The Two Parallel Streams:**

**Stream A: The Aggregate Stream (Global Account State)**
- Purpose: Tracks the total voting power of an account (User or Delegate) for voting and total supply calculations
- Mappings: `userHistory`, `delegateHistory`, `slopeChanges`, `userSlopeChanges`, `userPendingDeltas`
- Used By: `balanceOfAt()`, `totalSupplyAtTimestamp()`, and `_viewAccountAndGlobalAndPendingDeltas`

**Stream B: The Parallel Stream (Pair-Specific State)**
- Purpose: Tracks specifically how much voting power User A has contributed to Delegate B
- Mappings: `delegatedAggregationHistory`, `userDelegatedSlopeChanges`, `userPendingDeltasForDelegate`
- Used By: `getSpecificDelegatedBalanceAtEpochEnd` (for calculating the user's share of a delegate's rewards)

This separation enables:
- Independent voting with personal vs delegated power
- Accurate reward distribution in VotingController
- Clean delegation without affecting personal positions
- Precise tracking for reward calculations

## Forward-Delegation Mechanism

Delegation changes take effect in the next epoch to prevent double-voting exploits:

```solidity
// When delegating a lock:
// 1. Lock's voting power is scheduled to be removed from user in next epoch
userPendingDeltas[user][nextEpochStart].hasSubtraction = true;
userPendingDeltas[user][nextEpochStart].subtractions = lockVeBalance;

// 2. Lock's voting power is scheduled to be added to delegate in next epoch
delegatePendingDeltas[delegate][nextEpochStart].hasAddition = true;
delegatePendingDeltas[delegate][nextEpochStart].additions = lockVeBalance;

// 3. User-delegate pair tracking is also updated
userPendingDeltasForDelegate[user][delegate][nextEpochStart].hasAddition = true;
userPendingDeltasForDelegate[user][delegate][nextEpochStart].additions = lockVeBalance;
```

This ensures:
- No double voting in the current epoch
- Seamless transition of voting power
- Mathematical consistency across all operations

## Pending Deltas System

The pending deltas system manages future state changes using the `VeDeltas` struct:

```solidity
struct VeDeltas {
    bool hasAddition;        // Flag indicating additions pending
    bool hasSubtraction;     // Flag indicating subtractions pending
    VeBalance additions;     // veMOCA to be added
    VeBalance subtractions;  // veMOCA to be removed
}
```

**Three Pending Delta Mappings:**

1. **User Pending Deltas**: `userPendingDeltas[user][epochStart]`
   - Tracks pending changes to user's personal voting power
   - Applied when user state is updated

2. **Delegate Pending Deltas**: `delegatePendingDeltas[delegate][epochStart]`
   - Tracks pending changes to delegate's voting power
   - Applied when delegate state is updated

3. **Pair Pending Deltas**: `userPendingDeltasForDelegate[user][delegate][epochStart]`
   - Tracks pending changes for specific user-delegate pairs
   - Applied when pair state is updated
   - Critical for reward calculations in VotingController

**Application Order:**

During state updates (`_updateAccountAndGlobalAndPendingDeltas`, `_updatePendingForDelegatePair`), pending deltas are applied in sequence:

1. Advance to next epoch timestamp
2. Apply scheduled decay via slope changes
3. Apply pending additions (if `hasAddition == true`)
4. Apply pending subtractions (if `hasSubtraction == true`)
5. Checkpoint the new state
6. Delete the pending delta storage

**Complex Operations Enabled:**

This system allows sophisticated delegation operations:

- **Undelegating then redelegating in same epoch**: Changes queued to next epoch, mathematically cancel out
- **Switching delegates directly**: Single atomic operation via `switchDelegate()`
  - Subtracts from old delegate's next epoch
  - Adds to new delegate's next epoch
  - Updates both pair aggregations
- **Multiple delegation changes**: Can queue changes for different epochs
- **Lock modifications while delegated**: `_modifyLock()` updates pair state correctly

### Locks: Using expiry, instead of duration

When calculating bias, we use expiry (an absolute timestamp) instead of duration:

```solidity
slope = amount / MAXTIME                    // MAXTIME = 728 days
bias  = slope * expiryTimestamp
```

This forms the veBalance `{bias, slope}`, as if the lock started at t=0 (Unix epoch), yielding an inflated bias.

But we query the voting power via:

```solidity
votingPower = bias - (slope × currentTimestamp)
```

Alternatively expressed: `veBalance.bias - veBalance.slope * timestamp`

This subtraction correctly offsets the period before the lock began, ensuring accurate decay from the actual lock start time.

#### Why this is an improvement 

**Better efficiency, less storage, and lower gas costs:**

1. **Stores less data**: No need to record start time in Lock struct
2. **Lightweight queries**: Vote decay and veToken queries are simple calculations
3. **Easy aggregations**: 
   - Sum biases/slopes directly for global/user totals
   - Schedule changes via `slopeChanges[expiry]`
   - Avoid start-time storage and lookups
4. **Constant veBalance**: Lock's veBalance remains constant regardless of when calculated
5. **Simplified modifications**: `increaseAmount()` and `increaseDuration()` only need expiry

**Implementation in contract:**

```solidity
function _convertToVeBalance(DataTypes.Lock memory lock) internal pure returns (DataTypes.VeBalance memory) {
    DataTypes.VeBalance memory veBalance;
    
    // slope: decay rate per second
    veBalance.slope = (lock.moca + lock.esMoca) / EpochMath.MAX_LOCK_DURATION;
    
    // bias: inflated value as if lock started at Unix epoch
    veBalance.bias = veBalance.slope * lock.expiry;
    
    return veBalance;
}

function _getValueAt(DataTypes.VeBalance memory a, uint128 timestamp) internal pure returns (uint128) {
    uint128 decay = a.slope * timestamp;
    
    if(a.bias <= decay) return 0;
    
    // offset inception inflation to get actual voting power
    return a.bias - decay;
}
```

---

# VotingController Integration

The veMoca2 contract integrates tightly with VotingController for delegate management and voting power queries.

## Delegate Registration Functions

**`registerAsDelegate(address delegate)`**
- **Caller**: Only VotingController contract
- **Purpose**: Register delegate after they pay registration fee
- **Storage**: Sets `isRegisteredDelegate[delegate] = true`
- **Event**: Emits `DelegateRegistered(delegate)`
- **Note**: Registration fee collected by VotingController, not veMoca2

**`unregisterAsDelegate(address delegate)`**
- **Caller**: Only VotingController contract
- **Purpose**: Unregister delegate
- **Storage**: Sets `isRegisteredDelegate[delegate] = false`
- **Event**: Emits `DelegateUnregistered(delegate)`
- **Note**: Does not affect existing delegations; users retain delegated locks

## Query Functions for VotingController

**`balanceAtEpochEnd(address user, uint128 epoch, bool isDelegate)`**
- **Purpose**: Returns voting power at the END of a specific epoch
- **Used By**: `VotingController.vote()` to determine voting power
- **Parameters**:
  - `user`: Address to query (voter or delegate)
  - `epoch`: Epoch number (not timestamp)
  - `isDelegate`: true for delegate voting power, false for personal
- **Returns**: Voting power at `epochEndTime = epochStartTime + EPOCH_DURATION`
- **Restriction**: Can only query current or past epochs
- **Forward-Decay**: Applies full epoch decay to freeze intra-epoch changes

**Implementation:**
```solidity
function balanceAtEpochEnd(address user, uint128 epoch, bool isDelegate) external view returns (uint128) {
    // Convert epoch number to timestamp
    uint128 epochStartTime = EpochMath.getEpochStartTimestamp(epoch);
    require(epochStartTime <= EpochMath.getCurrentEpochStart(), Errors.InvalidTimestamp());
    
    // Get veBalance updated to epochStartTime
    (, DataTypes.VeBalance memory veAccount_) = _viewAccountAndGlobalAndPendingDeltas(user, epochStartTime, isDelegate);
    if(veAccount_.bias == 0) return 0;
    
    // Return voting power at END of epoch (forward-decay)
    uint128 epochEndTime = epochStartTime + EpochMath.EPOCH_DURATION;
    return _getValueAt(veAccount_, epochEndTime);
}
```

**`getSpecificDelegatedBalanceAtEpochEnd(address user, address delegate, uint128 epoch)`**
- **Purpose**: Returns user's specific contribution to delegate's voting power at epoch end
- **Used By**: `VotingController.claimRewardsFromDelegate()` to calculate user's share of delegate's rewards
- **Critical For**: Fair reward distribution among delegators
- **Returns**: User's delegated voting power to specific delegate at epoch end
- **Uses**: `delegatedAggregationHistory[user][delegate][epochStart]` mapping
- **Simulates**: Forward decay and pending deltas if pair state is stale

**Why This Query Is Needed:**

When a delegate earns rewards from voting, those rewards must be distributed proportionally to all users who delegated to that delegate. This function returns exactly how much voting power user A contributed to delegate B in a specific epoch, enabling precise reward calculations.

**Example:**
- User Alice delegated 100 veMOCA to Delegate Dave
- User Bob delegated 400 veMOCA to Delegate Dave  
- Dave's total: 500 veMOCA (at epoch end)
- Rewards earned by Dave: 1000 esMOCA
- Alice's share: `(100/500) * 1000 = 200 esMOCA`
- Bob's share: `(400/500) * 1000 = 800 esMOCA`

**Query Flow:**
```solidity
// VotingController calls this to determine Alice's share:
uint128 aliceContribution = veMoca2.getSpecificDelegatedBalanceAtEpochEnd(alice, dave, epoch);
uint128 totalDelegatedToDave = veMoca2.balanceAtEpochEnd(dave, epoch, true);
uint128 aliceShare = (aliceContribution * daveRewards) / totalDelegatedToDave;
```

## General Query Functions

**`balanceOfAt(address user, uint128 timestamp, bool isDelegate)`**
- **Purpose**: Returns voting power at ANY specific timestamp
- **Used By**: General queries, wallets, dApps
- **Parameters**:
  - `user`: Address to query
  - `timestamp`: Specific timestamp (not epoch number)
  - `isDelegate`: true for delegated power, false for personal
- **Returns**: Voting power at exact timestamp
- **Restriction**: Cannot query future timestamps
- **Note**: More flexible than `balanceAtEpochEnd()` but not used by VotingController

**`totalSupplyAtTimestamp(uint128 timestamp)`**
- **Purpose**: Returns total veMOCA supply at specific timestamp
- **Used By**: Analytics, governance calculations
- **Returns**: Global voting power at timestamp
- **Note**: Can query past or future timestamps
- **Caching**: Uses `totalSupplyAt[epochStart]` for past epochs

# Security & Safeguards

## Multi-Role Access Control

**Operational Roles:**
- **MONITOR_ROLE**: Can pause during emergencies (bot addresses)
- **CRON_JOB_ROLE**: Can create locks via `createLockFor` (automated service)

**Admin Roles:**
- **DEFAULT_ADMIN_ROLE**: Global admin - can unpause, freeze, manage role admins
- **VOTING_ESCROW_MOCA_ADMIN_ROLE**: Can set gas limits for MOCA transfers
- **MONITOR_ADMIN_ROLE**: Manages MONITOR_ROLE grants/revokes
- **CRON_JOB_ADMIN_ROLE**: Manages CRON_JOB_ROLE grants/revokes
- **EMERGENCY_EXIT_HANDLER_ROLE**: Can return funds when frozen

**Role Hierarchy:**
- Operational roles (MONITOR, CRON_JOB) managed by their dedicated admins
- Strategic roles (VOTING_ESCROW_MOCA_ADMIN, EMERGENCY_EXIT_HANDLER) managed by global admin
- Separation ensures operational efficiency while maintaining strategic oversight

## Three-Stage Emergency System

**Stage 1 - Pause** (Reversible):
- Stops all user operations (create, increase, delegate, unlock)
- Triggered by MONITOR_ROLE during emergencies
- Can be reversed by DEFAULT_ADMIN_ROLE via `unpause()`
- Does not affect view functions

**Stage 2 - Freeze** (Permanent):
- One-way operation from paused state
- Only callable by DEFAULT_ADMIN_ROLE when paused
- Sets `isFrozen = 1` permanently
- Prevents all future unpausing
- Enables `emergencyExit()` function

**Stage 3 - Emergency Exit**:
- Only callable when contract is frozen (`isFrozen == 1`)
- Executed by EMERGENCY_EXIT_HANDLER_ROLE
- Returns MOCA and esMOCA to lock owners
- Processes locks in batches via `lockIds` array
- Skips invalid/already processed locks
- Does not update veBalance states (system failure mode)
- Marks locks as `isUnlocked = true`
- Returns (totalLocksProcessed, totalMocaReturned, totalEsMocaReturned)

## Built-in Protections

**Amount & Duration Protections:**
- Minimum lock amounts prevent dust attacks (1e13 wei / 0.00001 tokens minimum)
- 3-epoch minimum liveliness ensures effectiveness
- Expiry must align with epoch boundaries (14-day multiples)
- Maximum lock duration: 728 days (~2 years)
- Minimum lock duration: 28 days (2 epochs)

**Delegation Protections:**
- Forward-booking prevents double-voting exploits
- Delegation only to registered delegates
- Cannot delegate to self
- Cannot delegate already delegated locks
- Lock must have 3 epochs remaining to delegate/switch/undelegate

**Transfer & Token Protections:**
- Non-transferable veMOCA prevents gaming
- Gas limit controls for MOCA transfers (configurable, default ≥ 2300)
- Automatic wrapping to wMOCA if native transfer fails
- SafeERC20 for esMOCA transfers

**State Management:**
- Pausable for emergency intervention
- Frozen state prevents recovery and enables emergency exits
- Global lock tracking via `TOTAL_LOCKED_MOCA` and `TOTAL_LOCKED_ESMOCA`

# Gas Optimizations

**Checkpoint Compression:**
- Same-epoch updates overwrite instead of append in `_pushCheckpoint()`
- Checks if `lockHistory[length - 1].lastUpdatedAt == currentEpochStart`
- Reduces storage writes significantly

**Batch Processing:**
- `createLockFor()`: Batch create locks for multiple users (CRON_JOB_ROLE)
- `updateAccountsAndPendingDeltas()`: Batch update stale accounts
- `updateDelegatePairs()`: Batch update user-delegate pairs
- Single global update per batch reduces gas costs
- Epoch alignment enables efficient loops

**Storage Efficiency:**
- Uses VeBalance struct (bias + slope) instead of storing amounts
- Lock ID generation via keccak256 avoids SSTORE counter costs
- Direct storage reads/writes for mappings
- Deleted fields reset to zero to reclaim gas

**Unchecked Arithmetic:**
- Safe unchecked blocks for epoch advancement (`lastUpdatedAt += epochDuration`)
- Mathematically proven safe given token supply constraints
- Saves gas on overflow checks

**Lazy Evaluation:**
- Voting power decays automatically without manual updates
- State updates only when necessary (user interaction)
- View functions avoid state updates entirely

**View Functions:**
- `balanceOfAt()`: Read-only balance queries
- `balanceAtEpochEnd()`: Optimized for VotingController
- `totalSupplyAtTimestamp()`: Global supply queries
- `getSpecificDelegatedBalanceAtEpochEnd()`: Pair-specific queries
- All avoid state modifications while simulating decay

# Batch Operations

The contract provides several batch operations to handle stale accounts and reduce gas costs:

## `createLockFor()` - Batch Lock Creation

**Purpose**: CRON_JOB_ROLE can create multiple locks in a single transaction

**Features:**
- Single expiry for all locks
- Arrays of users, mocaAmounts, esMocaAmounts
- Single global update for all locks
- Aggregates slope changes
- Validates `msg.value == totalMoca`
- Returns array of lockIds

**Gas Savings:**
- One global update vs N individual updates
- Batched slope change storage
- Efficient loop with unchecked operations

## `updateAccountsAndPendingDeltas()` - Batch Account Updates

**Purpose**: Admin helper to batch update stale accounts to current epoch

**Parameters:**
- `accounts[]`: Array of addresses to update
- `isDelegate`: True for delegates, false for users

**Features:**
- Fixes OOG risks for long-inactive accounts
- Single global update at batch start
- Processes each account through `_updateAccountAndGlobalAndPendingDeltas()`
- Updates: accountHistory, accountLastUpdated, pending deltas
- Emits events for each account

**Use Case:**
- Accounts inactive for many epochs accumulate pending updates
- Batch update before they attempt operations
- Prevents transaction failures due to gas limits

## `updateDelegatePairs()` - Batch Pair Updates

**Purpose**: Admin helper to batch update stale user-delegate pairs

**Parameters:**
- `users[]`: Array of user addresses
- `delegates[]`: Array of corresponding delegate addresses

**Features:**
- Essential for delegates claiming fees if pair is stale
- Single global update at batch start
- Processes pairs through `_updatePendingForDelegatePair()`
- Updates: delegatedAggregationHistory, userDelegatedPairLastUpdatedTimestamp
- Clears pending deltas for pairs

**Use Case:**
- User-delegate pair hasn't interacted in many epochs
- Delegate needs to claim fees but pair is stale
- Batch update multiple pairs efficiently

# Edge Cases Handled

**Mid-Epoch Lock Creation**: 
- Locks created mid-epoch can vote immediately in the same epoch
- Forward-decay ensures fair voting power (benchmarked to epoch end)
- No need to wait for next epoch (unlike Option 1 in design considerations)
- Lock booked to `currentEpochStart` in `userHistory`

**Final Epoch Problem**:
- Locks have non-zero veMOCA at epoch start
- Forward-decay shows 0 voting power at epoch end (intended behavior)
- Last usable epoch is always N-1 where lock expires in epoch N
- Enforced via 3-epoch minimum liveliness check

**Expired Delegations**:
- Users can always reclaim expired locks via `unlock()`
- No requirement for delegate to remain registered
- Automatic cleanup via lazy evaluation
- Lock cleanup handled in `unlock()` function

**Delegation State Transitions**:
- Undelegate + Delegate in same epoch = Switch (mathematically identical)
- Direct switching via `switchDelegate()` function atomically handles:
  - Removes lock from old delegate (subtracts from pending deltas)
  - Adds lock to new delegate (adds to pending deltas)
  - Updates slope changes for both delegates
  - Updates pair aggregation for both pairs
- No gaps in voting power during transitions
- All changes take effect next epoch

**First-Time Account Updates**:
- `accountLastUpdatedAt == 0` handled specially
- Sets `accountLastUpdatedAt = currentEpochStart`
- Returns zero veBalance
- Updates global if needed

**Stale Account Updates**:
- While loop processes missed epochs one by one
- Applies decay via slope changes per epoch
- Applies pending deltas per epoch
- Checkpoints state at each epoch boundary
- Global and account updated in parallel

**Lock Modifications (increaseAmount/Duration)**:
- `_modifyLock()` handles both scenarios
- Calculates delta between old and new veBalance
- Updates global, account, and pair states
- Handles slope change reassignment:
  - `increaseDuration`: Moves slope from old expiry to new expiry
  - `increaseAmount`: Increments slope at existing expiry

**View Function Consistency**:
- View functions (`_viewAccountAndGlobalAndPendingDeltas()`, `_viewGlobal()`) mirror state update logic
- No storage writes, only memory operations
- Apply same decay and pending delta logic
- Used by all external view functions for consistency

## Mid-epoch created locks - further details

Consider 2 identical locks with identical amount and same expiry time (lock A and lock B):

- lockA is created mid-way in Epoch 1 at day 15
- lockB is created 5 days after lockA, still within Epoch 1 at day 20

**Would they have the exact same veBalances?**

**Yes - they will have identical veBalances.**

```solidity
// VeBalance calculation in _convertToVeBalance():
veBalance.slope = (lock.moca + lock.esMoca) / MAX_LOCK_DURATION;  // 728 days
veBalance.bias = veBalance.slope * lock.expiry;

// Key insight:
// - slope depends ONLY on principal and MAX_LOCK_DURATION
// - bias depends ONLY on slope and expiry timestamp
// - Neither uses creation timestamp
```

**Why does this work?**

The slope is derived as `principal / MAX_LOCK_DURATION`.
The bias is derived as `slope * expiry`.
Neither the bias nor the slope depends on the lock's creation timestamp—only on the principal and expiry (which are identical for both locks).

The mid-epoch creation times (day 15 vs day 20) do not affect the VeBalance struct, as the system does not store or factor in a creation timestamp for veBalance calculations.

    Their voting power would not differ in epoch 2 (or any subsequent epoch). The difference in creation time does not result in a difference in the decay applied, as the veBalance for each lock (bias and slope) is derived solely from the principal amount and the absolute expiry timestamp—neither of which incorporates the creation timestamp. Consequently, at any given evaluation point (e.g., the end of epoch 2, as used for voting power benchmarking in the VotingController contract), both locks yield identical voting power values.

**What about voting power?**

```solidity
votingPower = bias - (slope * timestamp)
```

- This formula is consistent with the identical structs.
- Their voting power would not differ in epoch 2 (or any subsequent epoch). The difference in creation time does not result in a difference in the decay applied.

At any given evaluation point (e.g., the end of epoch 2, as used for voting power benchmarking in the VotingController contract), both locks yield identical voting power values.

**Practical implication:**

Users creating locks at different times within the same epoch with the same expiry will have identical veBalances, but the user who created their lock earlier will have had more time to utilize their voting power before any query is made.


---

# Summary

**Note**: This system prioritizes fairness and security over flexibility. 
- Early unlocks are not possible, and all time commitments must be honored
- In exchange, users gain a transparent, manipulation-resistant voting system with built-in emergency protections

**Key features in veMoca2:**

**Core Mechanics:**
- Enhanced delegation system with forward-booking (next epoch activation)
- Quad-accounting for precise reward distribution (global, user, delegate, pair)
- Pending deltas for seamless state transitions
- 3-epoch minimum lock liveliness requirements
- Epoch-based accounting (14-day epochs with frozen intra-epoch decay)

**User Operations:**
- Create locks with native MOCA and/or esMOCA
- Increase lock amount or extend duration
- Delegate, switch delegates, or undelegate locks
- Unlock after expiry to reclaim principals

**Optimizations:**
- Gas optimizations with unchecked arithmetic and batch operations
- Checkpoint compression (same-epoch overwrites)
- Lazy evaluation for automatic decay
- Efficient storage via VeBalance struct (bias + slope)

**Delegation Features:**
- Direct delegate switching functionality
- Registration via VotingController
- Pair-specific tracking for reward calculations
- Forward-delegation prevents double-voting

**Safety Features:**
- Three-stage emergency system (pause → freeze → exit)
- Multi-role access control with role hierarchy
- Minimum amounts (1e13 wei) prevent precision loss
- Gas limit controls for MOCA transfers (configurable)
- Emergency exit without state updates (system failure mode)

**Query Functions:**
- Specialized view functions for efficient balance queries
- `balanceOfAt()`: Personal or delegated voting power at timestamp
- `balanceAtEpochEnd()`: Voting power at epoch end (for VotingController)
- `totalSupplyAtTimestamp()`: Global supply at any timestamp
- `getSpecificDelegatedBalanceAtEpochEnd()`: User's share of delegate's voting power

**Technical Highlights:**
- Timestamp-based decay (not block-based) for chain-agnostic precision
- Lock expiry used instead of duration for efficient calculations
- No storage of creation timestamps needed
- Aggregation of voting power across all locks per user
- Mathematically proven overflow-safe given MOCA supply constraints