# AddressBook Contract Documentation

The AddressBook contract is the single source for all key addresses in the Moca ecosystem.
- centralizes address management under governance, making upgrades and integrations straightforward and secure.
- developers should always use AddressBook to fetch system addresses for reliable, future-proof integrations.

The contract is intentionally simple, focusing solely on address management as the core registry for the protocol.

> **Quick Facts**
> - **Purpose**: Central address registry for all protocol contracts
> - **Owner**: Governance multisig
> - **Contract Addition/Upgrade**: Update addresses here after deploying contracts

## Table of Contents

- [What Problem Does AddressBook Solve?](#what-problem-does-addressbook-solve)
- [Core Architecture](#core-architecture)
- [Key Design Features](#key-design-features)
- [Contract Initialization](#contract-initialization)
- [Contract Functions](#contract-functions)
  - [Ownership Transfer: Global Admin updates via custom Ownable2Step](#ownership-transfer-global-admin-updates-via-custom-ownable2step)
- [Integration Patterns](#integration-patterns)
- [Security Considerations](#security-considerations)
  - [Access Control Model](#access-control-model)
  - [Risk Management Architecture](#risk-management-architecture)
  - [Risks and Mitigations](#risks-and-mitigations)
- [Events and Monitoring](#events-and-monitoring)
- [Upgrade and Migration Patterns](#upgrade-and-migration-patterns)
  - [Generic Upgrade Flow](#generic-upgrade-flow)
  - [Emergency Procedures](#emergency-procedures)
  - [Initial Deployment Process](#initial-deployment-process)
- [Quick Reference](#quick-reference)
- [Future Considerations](#future-considerations)

## What Problem Does AddressBook Solve?

Without a central registry, each contract would need to hardcode addresses of other contracts, making upgrades and integration difficult.
Plus, human errors. 

AddressBook enables:

- **Seamless Upgrades**: When a contract is upgraded/redeployment, only the AddressBook needs updating
- **Modular Architecture**: Contracts remain loosely coupled through the address registry
- **Single Source of Truth**: Eliminates address inconsistencies across the system
- **Governance Control**: All address changes require governance approval

## Core Architecture

```
                            AddressBook
                                │
                        AccessController
                                │
        ┌───────────────────────┼─────────────────────┐
        │                       │                     │
     Tokens                Controllers             Treasury
        │                       │                     │
    ┌───┴───┐                   │                     │
    │       │      ┌────────────┼───────────┐         │
  MOCA    USD8     │            │           │      TREASURY [contract, multi-sig, etc]
    │        VotingController   │   PaymentsController
    ├─esMOCA              VotingEscrowedMoca
    │
    └─veMOCA
```

### Address Categories

The system organizes addresses into logical categories:

**Tokens**
- `MOCA`: The main protocol token (18 decimals)
- `ES_MOCA`: Escrowed MOCA tokens for rewards (18 decimals)
- `VOTING_ESCROW_MOCA`: Vote-locked MOCA with decay mechanics (18 decimals, non-transferable)
*- `USD8`: Stablecoin used for payments (6 decimal precision)  [not implemented atm]*
*- `USD8 Treasury`: [not implemented atm]*

  
**Controllers** 
- `ACCESS_CONTROLLER`: Manages permissions across the protocol
- `VOTING_CONTROLLER`: Handles governance voting and reward distribution
- `PAYMENTS_CONTROLLER`: Processes verification fees and payments
*- `ROUTER`: Routes transactions between different protocol components [not implemented atm]*
*- `CUSTOM MOCA LZ BRIDGE`: [not implemented atm]*
*- `MOCA<>gMOCA Wrapper`: [not implemented atm]*

**Treasury**
- `TREASURY`: Protocol-owned treasury for ecosystem funding
- this can take the form of a basic EOA, multi-sig, fully specified contract
- via the AddressBook, we can upgrade accordingly as needed

### Special Identifier: Global Admin

The protocol reserves identifier `bytes32(0)` for the Global Admin address, the highest privilege level in the system. 
- this address cannot be changed through `setAddress()` and requires the dedicated `updateGlobalAdmin()` function.
- separation is to prevent fat-fingering and ensuring updates are intentional.

## Key Design Features

### 1. **Immutable Identifiers, Mutable Addresses**

```solidity
// These identifiers are hardcoded and never change
bytes32 private constant MOCA = 'MOCA';              
bytes32 private constant TREASURY = 'TREASURY';      
bytes32 private constant USD8 = 'USD8';              
....

// the addresses they point to can be updated | declared internal so that public getter can be custom paused
mapping(bytes32 identifier => address registeredAddress) public _addresses;
```

This design ensures consistent naming while allowing address updates for upgrades.

### 2. **Governance-Controlled Updates**

All address changes require owner approval (multisig), ensuring:
- no unauthorized address modifications
- intentional and transparent upgrade processes

### 3. **Pausable Operations**

The contract inherits OpenZeppelin's Pausable pattern, allowing emergency suspension of **address updates and read access** for existing integrations.
Thus, when paused, any address calls would fail. 

**Pausing even the view functions was done deliberately; to ensure that the entire system built on the AddressBook and its contracts cannot wiggle by an incorrect/malicious txn call.**
**It would be a kill-switch, blocking contract inter-connectivity and any form of privileged access based exploits.**

>Naturally, if 3rd party protocols/integrators, choose to not adopt the AddressBook contract as a basis of reference, the risk is their own to handle and mitigate.

### 4. **Type-Safe Address Retrieval**

Along with generic lookups, AddressBook provides dedicated getter functions for important core contracts:

```solidity
function getMoca() external view returns (address)
function getAccessController() external view returns (address)  
function getTreasury() external view returns (address)
// .....
```

>Sleeker interfacing for contract integration, and eliminates typos in the identifier strings.

# Contract Initialization

### Constructor

The AddressBook is initialized with a single parameter:

```solidity
constructor(address globalAdmin) Ownable(globalAdmin) {
    // Set global admin at DEFAULT_ADMIN_ROLE (bytes32(0))
    addresses[bytes32(0)] = globalAdmin;
}
```

**Key Points**:
- The deployer must provide the initial Global Admin address
- This address receives ownership through OpenZeppelin's Ownable
- The Global Admin is stored at the special identifier `bytes32(0)` *[matching AccessControl's pattern]*

**No other addresses are set during deployment; they must be set post-deployment.**

## Contract Functions

### Administrative Functions

#### `setAddress(bytes32 identifier, address registeredAddress)`

**Purpose**: Updates the address for any existing contracts, and allows additions of new contracts to the registry.
**Access**: Only contract owner 
**Restrictions**: 
- Cannot modify the global admin - reverts with `Invalid identifier`
- Cannot set zero address - reverts with `Invalid address`
- Only callable when not paused

**Example Usage**: When upgrading the VotingController, governance calls:
```solidity
// Convert string to bytes32 identifier
addressBook.setAddress(bytes32('VOTING_CONTROLLER'), newVotingControllerAddress);
```

**Error Cases**:
```solidity
// ❌ Trying to change global admin through setAddress
addressBook.setAddress(bytes32(0), newAdmin); // Reverts: "Invalid identifier"

// ❌ Setting zero address
addressBook.setAddress('MOCA', address(0)); // Reverts: "Invalid address"
```

### Ownership Transfer: Global Admin updates via custom Ownable2Step

**Purpose**: The global admin can only be changed through ownership transfer
**Access**: Current owner initiates transfer, new owner must accept

The AddressBook contract overrides the internal `_transferOwnership(address newOwner)` function to ensure that global admin changes are synchronized across the protocol. 
This is the **only way** to update the global admin address.

**How it works**:
1. Current owner calls `transferOwnership(newOwner)` 
2. New owner calls `acceptOwnership()` to complete the transfer
3. The `_transferOwnership` override automatically:
   - Updates the stored global admin address at `bytes32(0)` to the new owner
   - If an AccessController is registered, calls `transferGlobalAdminFromAddressBook` on it, passing both old and new admin addresses
   - Emits a `GlobalAdminUpdated` event for off-chain tracking

This design ensures protocol-wide admin transitions are atomic and consistent, preventing any mismatch between the AddressBook owner and the global admin role across the system.

### Address Retrieval Functions

Each system component has a dedicated getter function that returns its current address:

```bash
// Token addresses
getUSD8() → returns USD8 stablecoin address
getMoca() → returns main MOCA token address  
getEscrowedMoca() → returns escrowed MOCA address
getVotingEscrowMoca() → returns vote-locked MOCA address

// Controller addresses
getAccessController() → returns permission manager address
getVotingController() → returns governance system address
getPaymentsController() → returns fee processing address

// Treasury address
getTreasury() → returns protocol treasury address

// Router [for future use]
getRouter() → returns router address
```

**Note**: 
- These functions do not validate returned addresses against zero. 
- Calling contracts are expected to handle zero address checks according to their specific requirements.
- All getter functions have `whenNotPaused` modifier - view functions are blocked during emergency pauses.

>Why no zero address validation? 
>Deprecation: AddressBook might legitimately return zero for deprecated contracts. [Plus flexibility for future update patterns currently unthought of]

## Integration Patterns

### For Contract Developers

When building contracts that interact with the Moca ecosystem:

1. **Store AddressBook reference**:
```solidity
IAddressBook immutable ADDRESS_BOOK;
```

2. **Fetch addresses dynamically**:
```solidity
address votingController = ADDRESS_BOOK.getVotingController();
require(votingController != address(0), "VotingController not set");
```

3. **Never cache addresses** - always fetch fresh to get latest updates

### For Frontend Developers

AddressBook serves as the single source for all contract addresses:

```javascript
const addressBook = new Contract(ADDRESS_BOOK_ADDRESS, abi, provider);
const mocaAddress = await addressBook.getMoca();
const treasuryAddress = await addressBook.getTreasury();
```

# Security Considerations

## Access Control Model

- **Owner**: Governance multisig with full control over address updates & risk functions [`pause`, `unpause`, `freeze`]
- **Users**: Read-only access to address information

Note that since this is not an asset-bearing contract, there are no emergencyExit functions. 
- Any assets sent to this contract will be stuck with no means of retrieval.

## Transferring Ownership 

Ownership can be transferred when contract is paused.
Why:

Consider the standard execution flow when pause might be triggered:
    1. something awry/malicious happens in the protocol
    2. owner pauses the contract
    3. owner assesses the severity of the issue and decides whether to freeze the contract
    4. if critical, owner freezes the contract

**Since it's the owner who is the only one allowed to call pause, seems immaterial whether transferring ownership should be blocked during paused state.**

### Risk Management Architecture

The contract implements a three-tier risk management system:

1. **Pause/Unpause**: Temporary suspension of all operations
   - `pause()`: Stops all address updates (owner only, when not frozen)
   - `unpause()`: Resumes operations (owner only, when not frozen)
   - **Important**: Even view functions are blocked when paused, preventing address reads during emergencies

2. **Freeze**: Permanent kill switch
   - `freeze()`: One-way operation that permanently disables the contract
   - Can only be called when already paused (two-step safety)
   - Once frozen, contract cannot be unfrozen or unpaused
   - Emits `ContractFrozen` event

3. **State Variable**: `isFrozen`
   - `0` = Normal operation
   - `1` = Permanently frozen

### Risks and Mitigations

**Risk**: Frontend applications using stale addresses  
**Mitigation**: Always query AddressBook for latest addresses rather than caching

**Risk**: Circular dependencies between contracts  
**Mitigation**: Careful architecture review and initialization/deployment ordering

## Events and Monitoring

### `AddressSet(bytes32 indexed identifier, address indexed registeredAddress)`
Emitted when any system address is updated. Critical for:
- Off-chain monitoring systems
- Frontend cache invalidation  
- Audit trail maintenance

### `GlobalAdminUpdated(address indexed oldAdmin, address indexed newAdmin)`
Emitted specifically for Global Admin changes. Enables:
- Enhanced monitoring of privilege escalation
- Separate alerting for highest-risk operations

### `ContractFrozen()`
Emitted when the contract is permanently frozen. Signals:
- Critical security response activated
- No further operations possible
- Immediate migration required

## Upgrade and Migration Patterns

### Generic Upgrade Flow

1. **Deploy New Contract**: Deploy upgraded version of target contract or a completely new contract
2. **Test Integration**: Verify new contract works with existing ecosystem
3. **Governance Proposal**: Submit address update/addition to governance [Call `setAddress()` with new contract address]
4. **Execute Update**: Owner multi-sign singers will sign off on transaction for it to be executed.
5. **Verify Systems**: Confirm all integrations work with new address

### Emergency Procedures

In case of contract vulnerabilities:

**Level 1 - Temporary Pause**:
1. **Pause AddressBook**: Prevents all operations (including reads)
2. **Investigate**: Determine severity and response
3. **Fix Issue**: Deploy patches if needed
4. **Unpause**: Resume normal operations

**Level 2 - Permanent Freeze** (Critical breach):
1. **Pause First**: Contract must be paused before freezing
2. **Freeze Contract**: Execute one-way freeze operation
3. **Deploy New AddressBook**: Create replacement contract
4. **Migrate Systems**: Update all contracts to use new AddressBook

⚠️ **Warning**: Freezing is irreversible. Use only for critical security breaches.

### Initial Deployment Process

1. **Deploy AddressBook First**: With governance multisig as global admin
2. **Deploy Core Contracts**: Deploy all system contracts
3. **Register Addresses**: Call `setAddress()` for each deployed contract
4. **Verify Integration**: Ensure all contracts can resolve addresses correctly
5. **Transfer Ownership**: If needed, transfer AddressBook ownership to final governance

**Example Deployment Script**:
```javascript
// 1. Deploy AddressBook
const addressBook = await AddressBook.deploy(governanceMultisig);

// 2. Deploy other contracts
const moca = await MocaToken.deploy();
const votingController = await VotingController.deploy(addressBook.address);

// 3. Register all addresses
await addressBook.setAddress(ethers.utils.formatBytes32String('MOCA'), moca.address);
await addressBook.setAddress(ethers.utils.formatBytes32String('VOTING_CONTROLLER'), votingController.address);
```

## Quick Reference

### Common Identifiers
```solidity
// Tokens
'MOCA'                // Main protocol token
'ES_MOCA'            // Escrowed MOCA
'VOTING_ESCROW_MOCA' // Vote-escrowed MOCA
'USD8'               // USD stablecoin (8 decimals)

// Controllers
'ACCESS_CONTROLLER'   // Permission management
'VOTING_CONTROLLER'   // Governance & rewards
'PAYMENTS_CONTROLLER' // Fee processing
'ROUTER'             // Transaction routing

// Treasury
'TREASURY'           // Protocol treasury

// Special
bytes32(0)           // Global Admin (DEFAULT_ADMIN_ROLE)
```

### Key Functions Cheat Sheet

| Function                               | Access         | Purpose                                                         |
|----------------------------------------|----------------|-----------------------------------------------------------------|
| `setAddress(identifier, address)`      | Owner          | Register or update any address except global admin              |
| `acceptOwnership()`                    | Pending Owner  | Complete ownership and global admin transfer                    |
| `pause()`                              | Owner          | Pause all contract operations (including reads)                 |
| `unpause()`                            | Owner          | Resume operations (if not frozen)                               |
| `freeze()`                             | Owner          | Permanently disable contract (irreversible)                     |
| `getAddress(identifier)`               | Public         | Generic address lookup by identifier                            |
| `getUSD8()`                            | Public         | Get USD8 stablecoin address                                     |
| `getMoca()`                            | Public         | Get MOCA token address                                          |
| `getEscrowedMoca()`                    | Public         | Get escrowed MOCA address                                       |
| `getVotingEscrowMoca()`                | Public         | Get vote-escrowed MOCA address                                  |
| `getAccessController()`                | Public         | Get access controller address                                   |
| `getVotingController()`                | Public         | Get voting controller address                                   |
| `getPaymentsController()`              | Public         | Get payments controller address                                 |
| `getTreasury()`                        | Public         | Get protocol treasury address                                   |
| `getGlobalAdmin()`                     | Public         | Get global admin address (DEFAULT_ADMIN_ROLE)                   |
| `getRouter()`                          | Public         | Get router address                                              |


### Error Messages
- `"Invalid identifier"` - Attempting to modify global admin via setAddress
- `"Invalid address"` - Trying to set zero address
- `"Pausable: paused"` - Contract is paused
- `"Ownable: caller is not the owner"` - Unauthorized access
- `IsFrozen()` - Contract is permanently frozen (custom error)

---

---
## Future Considerations

The AddressBook is designed to be stable and long-lived. Potential enhancements might include:

- **Address Validation**: On-chain verification of contract interfaces
- **Version Tracking**: Historical address records for audit purposes 
- **Proxy Detection**: Automatic detection and handling of proxy contracts
- **Multi-Network Support**: Cross-chain address synchronization

Things to consider in-line with AccessControllerV2 - for the future.
