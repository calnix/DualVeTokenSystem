# VotingController Contract 

## Executive Summary

VotingController is the governance hub of the protocol's voting ecosystem:
- Manages voting, reward distribution, and subsidy payments
- Enables users to vote on credential pools, delegates to manage voting on behalf of others, and verifiers to receive subsidies for their services
- Operates entirely on-chain with no reliance on external relayers

Think of VotingController as a sophisticated voting booth combined with a rewards distribution center; users cast votes to direct protocol resources, earn rewards for participation, and delegates can offer  voting services for a fee.

## Table of Contents

1. [Key & Unique Design Components](#key--unique-design-components)
   - [On-Chain Delegations with Fee Charging](#1-on-chain-delegations-with-fee-charging)
   - [Historical Fee Tracking Solution](#2-historical-fee-tracking-solution)
2. [Core Concepts](#core-concepts)
   - [What is VotingController?](#what-is-votingcontroller)
   - [Key Participants](#key-participants)
   - [The Epoch System](#the-epoch-system)
3. [Architecture Overview](#architecture-overview)
   - [Dual-Accounting Model](#dual-accounting-model)
   - [Integration Points](#integration-points)
4. [Key Features](#key-features)
   - [Voting Mechanics](#voting-mechanics)
   - [Delegation System](#delegation-system)
   - [Rewards & Subsidies](#rewards--subsidies)
5. [Contract Walkthrough](#contract-walkthrough)
   - [State Variables](#state-variables)
   - [Core Functions](#core-functions)
6. [User Flows](#user-flows)
   - [Voting Flow](#voting-flow)
   - [Delegation Flow](#delegation-flow)
   - [Claiming Rewards](#claiming-rewards)
7. [End of Epoch Execution Flows](#end-of-epoch-execution-flows)
8. [Technical Deep Dive](#technical-deep-dive)
   - [Rewards & Subsidies: Optimal Distribution](#rewards--subsidies-optimal-distribution)
   - [Residuals Management](#residuals-management)
   - [Historical Fee Tracking](#accurate-delegate-fee-application-historical-fee-tracking)
   - [Delegated Reward Claiming](#delegated-reward-claiming-per-pool-per-delegate-tracking)
   - [Safe Downcasting in claimSubsidies](#safe-downcasting-in-claimsubsidies)
   - [Why uint128 Is Safe](#why-uint128-is-safe-for-vote--reward-accounting)
   - [Overflow Analysis](#overflow-analysis)
   - [Gas Optimization](#gas-optimization)
9. [Epoch State Lifecycle](#epoch-state-lifecycle)
10. [Kill Switch & Operational Dependencies](#kill-switch--operational-dependencies)
11. [Security & Risk Management](#security--risk-management)

---

## Key & Unique Design Components

### 1. On-Chain Delegations with Fee Charging

VotingController processes all delegations entirely on-chain. This approach ensures:

- **Complete Transparency**: All delegation activities and fee calculations are verifiable on-chain
- **Trustless Operation**: No dependency on third-party relayers or off-chain scripts
- **Accurate Fee Distribution**: Fees are calculated and distributed precisely between delegators and delegates

> Most protocols avoid on-chain delegation due to the complexity of handling dynamic fee updates and gas costs. We've solved these challenges through innovative design patterns and gas-efficient implementations.

### 2. Historical Fee Tracking Solution

Traditional Ve systems struggle with calculating and distributing delegation fees on-chain:

- Rewards are distributed on an epoch basis
- Delegate fees are applied at the prevailing `currentFee`- the delegate's fee value at the time of a user's reward claim
- This leads to inaccuracies because fees could have been updated at any time; a user claiming for some arbitrary past epoch would be subject to the prevailing `currentFee`

> **TLDR**: The naive approach simply charges the user the prevailing delegate fee at the time of claiming, whatever that may be.

#### How We Solved It: Historical Fee Snapshots and Epoch-Specific Queries

To ensure fees are accurately applied for their respective epochs, we implemented a historical fee tracking system:

```solidity
// 100%: 10_000, 1%: 100, 0.1%: 10 | 2dp precision (XX.yy)
mapping(address delegate => mapping(uint128 epoch => uint128 currentFeePct)) public delegateHistoricalFeePcts;  
```

**How It Works:**
- **Fee Decreases**: Applied immediately to benefit users (retroactively overwrites any prior snapshot for the epoch)
- **Fee Increases**: Subject to a mandatory delay (e.g., `FEE_INCREASE_DELAY_EPOCHS`), preventing surprise changes
- **Epoch-Specific Tracking**: When delegates vote, their current fee is logged to `delegateHistoricalFeePcts` for that epoch via `_validateDelegateAndRecordFee()`
- **Fair Claims**: Users always pay the fee that was active when their rewards were earned, not the prevailing fee

This approach eliminates the possibility of delegates gaming the system by changing fees retroactively, ensuring a fair and predictable experience for all participants.

---

## Core Concepts

### What is VotingController

VotingController is a smart contract that orchestrates the protocol's governance through a vote-to-earn mechanism. It allows token holders to:
- Direct protocol resources by voting on credential pools
- Earn rewards proportional to their voting participation
- Delegate voting power to professional voters (delegates)
- Distribute subsidies to verifiers

### Key Participants

**1. Voters (veToken Holders)**
- Hold veMOCA tokens (voting power) from VotingEscrowMoca contract
- Vote on credential pools to direct protocol resources
- Earn esMOCA rewards based on future verification fees

**2. Delegates**
- Professional voters who manage voting on behalf of others
- Charge fees (as a percentage) for their services
- Must register and pay a one-time registration fee (in native MOCA)

**3. Verifiers**
- Service providers who verify credentials
- Receive subsidies based on their activity and pool votes
- Claim subsidies after epoch finalization

**4. Protocol Administrators**
- Manage epoch transitions and fund distribution
- Set protocol parameters and handle emergency situations

### The Epoch System

The protocol operates in fixed time periods called "epochs":
- Each epoch represents a voting and reward cycle
- Votes cast in epoch N influence rewards distributed in epoch N+1
- Epochs have clear start/end boundaries for fair accounting
- All rewards and subsidies are calculated per epoch

**An Epoch is 14 days.**

---

## Architecture Overview

### Dual-Accounting Model

VotingController implements a dual-accounting system where every address maintains two separate accounts:

**Personal Account**: Tracks direct voting activity
- Records votes cast with user's own veMOCA
- Accumulates rewards from personal voting

**Delegate Account**: Tracks delegated voting activity
- Records votes cast with delegated veMOCA from others
- Accumulates gross rewards and fees earned as a delegate

This design allows any address to seamlessly switch between being a voter and a delegate without separate contracts or complex state management.

### Integration Points

```
┌─────────────────────┐
│ VotingEscrowMoca    │ ◄── Provides voting power (veMOCA)
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│ VotingController    │ ◄── Central voting & rewards hub
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│ PaymentsController  │ ◄── Tracks verification fees & subsidies
└─────────────────────┘
```

---

## Key Features

### Voting Mechanics

**Forward-Decay Voting Power**
- Voting power is calculated at the end of the current epoch via `VEMOCA.balanceAtEpochEnd()`
- Prevents gaming through time-based decay
- Ensures fair representation across the epoch

**Multi-Pool Voting**
- Users can vote on multiple pools in a single transaction
- Vote migration allowed within the current epoch without decay penalty
- Cannot vote once `isSubsidiesSet` flag is true (end-of-epoch operations underway)

**Pool IDs**
- Pools are identified by sequential `uint128` IDs starting from 1
- Batch creation via `createPools(count)` creates `count` consecutive pools
- Maximum 50 pools per `createPools`/`removePools` call

### Delegation System

**On-Chain Delegation**
- Fully on-chain delegation with no relayer dependencies
- Delegates set fee percentages (e.g., 10% of rewards)
- Fee increases have mandatory delay (protection for users)
- Fee decreases apply immediately (user-friendly)

**Historical Fee Tracking**
- Fees are tracked per epoch to ensure fairness
- Users pay the fee that was active when rewards were earned
- Prevents retroactive fee changes from affecting past epochs

### Rewards & Subsidies

**Voting Rewards (for Voters)**
- Funded by verification fees from PaymentsController
- Distributed proportionally: `userRewards = (userVotes × poolRewards) / totalPoolVotes`
- Claimed in esMOCA tokens
- "Bet on the future" model—vote in epoch N, earn from epoch N+1 fees

**Verification Subsidies (for Verifiers)**
- Treasury-funded incentives for verifiers
- Proportional to verifier activity and pool votes
- Claimed after epoch finalization

---

## Contract Walkthrough

### State Variables

#### Global Counters
```solidity
uint128 public TOTAL_POOLS_CREATED;          // Total pools ever created
uint128 public TOTAL_ACTIVE_POOLS;           // Currently active pool count

uint128 public TOTAL_SUBSIDIES_DEPOSITED;    // Total subsidies ever deposited
uint128 public TOTAL_SUBSIDIES_CLAIMED;      // Total subsidies ever claimed

uint128 public TOTAL_REWARDS_DEPOSITED;      // Total rewards ever deposited
uint128 public TOTAL_REWARDS_CLAIMED;        // Total rewards ever claimed
```

#### Configuration Parameters
```solidity
uint128 public DELEGATE_REGISTRATION_FEE;    // Fee to register as delegate (in native MOCA)
uint128 public MAX_DELEGATE_FEE_PCT;         // Maximum delegate fee (10000 = 100%)
uint128 public FEE_INCREASE_DELAY_EPOCHS;    // Delay for fee increases (in epochs)
uint128 public UNCLAIMED_DELAY_EPOCHS;       // Delay before unclaimed funds can be swept
uint128 public MOCA_TRANSFER_GAS_LIMIT;      // Gas limit for native MOCA transfers
```

#### Registration Fee Tracking
```solidity
uint128 public TOTAL_REGISTRATION_FEES_COLLECTED;    
uint128 public TOTAL_REGISTRATION_FEES_CLAIMED;
```

#### Core Mappings

**Epoch & Pool Data**
```solidity
mapping(uint128 epochNum => DataTypes.Epoch epoch) public epochs;    
mapping(uint128 poolId => DataTypes.Pool pool) public pools;
mapping(uint128 epochNum => mapping(uint128 poolId => DataTypes.PoolEpoch poolEpoch)) public epochPools;
```

**User & Delegate Accounting**
```solidity
// Personal voting
mapping(uint128 epochNum => mapping(address userAddr => DataTypes.Account userAccount)) public usersEpochData;
mapping(uint128 epochNum => mapping(uint128 poolId => mapping(address user => DataTypes.Account userAccount))) public usersEpochPoolData;

// Delegated voting
mapping(uint128 epochNum => mapping(address delegateAddr => DataTypes.Account delegate)) public delegateEpochData;
mapping(uint128 epochNum => mapping(uint128 poolId => mapping(address delegate => DataTypes.Account delegateAccount))) public delegatesEpochPoolData;
```

**User-Delegate Pair Tracking**
```solidity
// For delegated reward claiming
mapping(uint128 epochNum => mapping(address user => mapping(address delegate => DataTypes.UserDelegateAccount userDelegateAccount))) public userDelegateAccounting;
```

**Delegate Data**
```solidity
mapping(address delegateAddr => DataTypes.Delegate delegate) public delegates;     
mapping(address delegate => mapping(uint128 epoch => uint128 currentFeePct)) public delegateHistoricalFeePcts;
```

**Verifier Subsidy Tracking**
```solidity
mapping(address verifier => uint128 totalSubsidies) public verifierSubsidies;                  
mapping(uint128 epoch => mapping(address verifier => uint128 totalSubsidies)) public verifierEpochSubsidies;
mapping(uint128 epoch => mapping(uint128 poolId => mapping(address verifier => uint128 totalSubsidies))) public verifierEpochPoolSubsidies;
```

### Core Functions

#### Voting Functions

**`vote(uint128[] poolIds, uint128[] poolVotes, bool isDelegated)`**
- Cast votes for one or more pools
- `isDelegated`: true = use delegated voting power, false = use personal power
- Validates voting power availability via `VEMOCA.balanceAtEpochEnd()`
- Updates all relevant vote tallies
- Cannot be called once `isSubsidiesSet` is true

**`migrateVotes(uint128[] srcPoolIds, uint128[] dstPoolIds, uint128[] votesToMigrate, bool isDelegated)`**
- Move votes between pools within current epoch
- Can migrate from inactive to active pools (but not vice versa)
- Maintains vote conservation (no creation/destruction)
- If migrating from an inactive pool, restores votes to `epoch.totalVotes`

#### Delegation Functions

**`registerAsDelegate(uint128 feePct)`**
- Register as a delegate with specified fee percentage
- Requires payment of `DELEGATE_REGISTRATION_FEE` in native MOCA
- Activates delegate status in VotingEscrowMoca via `VEMOCA.delegateRegistrationStatus()`

**`updateDelegateFee(uint128 newFeePct)`**
- Modify delegate fee percentage
- Increases: scheduled for `currentEpoch + FEE_INCREASE_DELAY_EPOCHS`
- Decreases: apply immediately and retroactively for current epoch

**`unregisterAsDelegate()`**
- Removes delegate status
- Cannot unregister if delegate has active votes in current epoch
- Registration fee is non-refundable

#### Claiming Functions

**`claimPersonalRewards(uint128 epoch, uint128[] poolIds)`**
- Claim rewards from personal voting
- Must wait for epoch finalization
- Rewards paid in esMOCA
- Prevents double-claiming via `userPoolAccountPtr.totalRewards` check

**`claimRewardsFromDelegates(uint128 epoch, address[] delegateList, uint128[][] poolIds)`**
- Claim net rewards from delegated voting across multiple delegates
- Automatically deducts delegate fees based on historical rates
- Supports batch claiming for gas efficiency

**`delegateClaimFees(uint128 epoch, address[] delegators, uint128[][] poolIds)`**
- Delegates claim their earned fees from multiple delegators
- Processes multiple delegators in one transaction
- Uses historical fee rates (not current rates)

*Note:*
- `claimRewardsFromDelegates()` and `delegateClaimFees()` are complementary functions for delegated voting
- Either party can trigger the reward/fee calculation and claim their share independently

**`claimSubsidies(uint128 epoch, address verifier, uint128[] poolIds)`**
- Verifiers claim esMOCA subsidies for their pools in a finalized epoch
- Only the registered asset address for the verifier can call (verified by PaymentsController)
- Calculates each pool's subsidy share based on verifier's activity ratio
- Prevents double-claims with per-pool tracking

#### Pool Management (VotingControllerAdmin Role)

**`createPools(uint128 count)`**
- Creates multiple voting pools in a single transaction
- Sequential IDs from `TOTAL_POOLS_CREATED + 1` to `TOTAL_POOLS_CREATED + count`
- Maximum 50 pools per call
- Blocked during active epoch finalization

**`removePools(uint128[] poolIds)`**
- Removes multiple pools from active voting
- Reduces `epoch.totalVotes` by votes in removed pools
- Maximum 50 pools per call

*Impact of removing pools mid-epoch:*
- Users who voted for removed pools can migrate their votes to active pools
- If not migrated: rewards for those votes are lost
- Votes in removed pools are subtracted from `epoch.totalVotes`

#### Epoch Management (CronJob Role)

**`depositEpochSubsidies(uint128 epoch, uint128 subsidies)`**
- Deposits treasury-funded subsidies for distribution
- Must be called after epoch ends, before finalization
- Can only be called once per epoch
- If no active pools: instantly finalizes the epoch (sets all flags to true)

**`processEpochRewardsSubsidies(uint128 epoch, uint128[] poolIds, uint128[] rewards)`**
- Allocates rewards and subsidies for specified pools
- Each pool can only be processed once per epoch
- Sets `isFullyProcessed = true` when all active pools are processed
- Can be called multiple times to process all pools in batches

**`finalizeEpoch(uint128 epoch)`**
- Transfers rewards from treasury to contract
- Sets `isEpochFinalized = true`
- Opens claiming for users and verifiers

**`forceFinalizeEpoch(uint128 epoch, bool blockClaims)`**
- Emergency function to force finalize an epoch
- If `blockClaims = true`: sets `isRewardsWithdrawn` and `isSubsidiesWithdrawn` to block claims
- Only callable by `DEFAULT_ADMIN_ROLE`

#### Asset Recovery Functions (AssetManager Role)

**`withdrawUnclaimedRewards(uint128 epoch)`**
- Sweeps unclaimed rewards after `UNCLAIMED_DELAY_EPOCHS`
- Sets `isRewardsWithdrawn = true` to block future claims
- Transfers to treasury

**`withdrawUnclaimedSubsidies(uint128 epoch)`**
- Sweeps unclaimed subsidies after `UNCLAIMED_DELAY_EPOCHS`
- Sets `isSubsidiesWithdrawn = true` to block future claims
- Transfers to treasury

**`withdrawRegistrationFees()`**
- Withdraws collected delegate registration fees (native MOCA)
- Uses `_transferMocaAndWrapIfFailWithGasLimit` for safe transfer

#### Configuration Functions (VotingControllerAdmin Role)

- `setEsMoca(address)` - Update esMOCA token address
- `setPaymentController(address)` - Update PaymentsController address
- `setVotingControllerTreasury(address)` - Update treasury address
- `setDelegateRegistrationFee(uint128)` - Update registration fee (0 allowed)
- `setMaxDelegateFeePct(uint128)` - Update max delegate fee percentage
- `setFeeIncreaseDelayEpochs(uint128)` - Update fee increase delay
- `setUnclaimedDelay(uint128)` - Update unclaimed sweep delay
- `setMocaTransferGasLimit(uint128)` - Update gas limit for MOCA transfers

#### Risk Management Functions

**`pause()` (Monitor Role)**
- Immediately halts all user operations

**`unpause()` (DEFAULT_ADMIN_ROLE)**
- Resumes normal operations after pause
- Cannot be called if contract is frozen

**`freeze()` (DEFAULT_ADMIN_ROLE)**
- Permanently disables the contract (one-way)
- Enables emergency asset recovery

**`emergencyExit()` (EmergencyExitHandler Role)**
- Recovers all contract-held assets when frozen
- Transfers esMOCA and native MOCA to treasury
- Disregards all outstanding claims

---

## User Flows

### Voting Flow

1. User holds veMOCA (from VotingEscrowMoca)
2. User calls `vote()` with pool selections
3. Contract validates available voting power at epoch end
4. Votes recorded for current epoch
5. After epoch is finalized, user can claim rewards

### Delegation Flow

**For Delegators:**
1. User delegates veMOCA to registered delegate (via VotingEscrowMoca)
2. Delegate votes on user's behalf
3. User claims net rewards (gross minus delegate fee) via `claimRewardsFromDelegates()`

**For Delegates:**
1. Register as delegate via `registerAsDelegate()` with fee percentage
2. Receive delegated veMOCA from users
3. Vote using aggregated delegated power
4. Claim fees from delegator rewards via `delegateClaimFees()`

### Claiming Rewards

The claiming process follows strict epoch boundaries:

1. **Epoch N**: Users vote on pools
2. **Epoch N+1**: Pools generate verification fees
3. **End of Epoch N+1**: Admin finalizes epoch with rewards
4. **After finalization**: Users claim their proportional rewards

---

## End of Epoch Execution Flows

When an epoch ends, critical operations must occur in a specific order:

### Step 1: Deposit Epoch Subsidies

**Function:** `depositEpochSubsidies(uint128 epoch, uint128 subsidies)`  
**Caller:** CRON_JOB_ROLE  
**When:** After epoch ends, before finalization

- Sets `isSubsidiesSet = true` and logs `totalActivePools`
- If `TOTAL_ACTIVE_POOLS == 0`: instantly sets `isFullyProcessed = true` and `isEpochFinalized = true`
- Deposits subsidies from treasury if `subsidies > 0` and `epoch.totalVotes > 0`

### Step 2: Process Epoch Rewards & Subsidies

**Function:** `processEpochRewardsSubsidies(uint128 epoch, uint128[] poolIds, uint128[] rewards)`  
**Caller:** CRON_JOB_ROLE  
**When:** After subsidies are deposited

For each pool:
- Calculates pool subsidies: `poolSubsidies = (poolVotes × totalSubsidiesAllocated) / totalVotes`
- Sets pool rewards from input array
- Marks pool as `isProcessed = true`
- Increments `poolsProcessed` counter

When all pools processed: sets `isFullyProcessed = true`

### Step 3: Finalize Epoch

**Function:** `finalizeEpoch(uint128 epoch)`  
**Caller:** CRON_JOB_ROLE  
**When:** After all pools are processed

- Transfers total rewards from treasury to contract
- Sets `isEpochFinalized = true`
- Emits `EpochFinalized` event

### Step 4: Claims Open

After finalization, users and verifiers can claim:
- **Personal rewards**: `claimPersonalRewards()`
- **Delegated rewards**: `claimRewardsFromDelegates()` / `delegateClaimFees()`
- **Verifier subsidies**: `claimSubsidies()`

### Post-Epoch Cleanup

After `UNCLAIMED_DELAY_EPOCHS`:
- `withdrawUnclaimedRewards()` - Recovers unclaimed voter rewards
- `withdrawUnclaimedSubsidies()` - Recovers unclaimed verifier subsidies

### Timeline Example

For 14-day epochs:
- **Day 0-14**: Epoch N active (voting occurs)
- **Day 14**: Epoch N ends
- **Day 14-15**: Admin deposits subsidies → processes pools → finalizes
- **Day 15+**: Claims open for epoch N
- **Day 98+**: Unclaimed funds can be swept (assuming 6 epoch delay)

---

## Technical Deep Dive

### Rewards & Subsidies: Optimal Distribution

#### The Core Challenge

Distributing rewards and subsidies fairly and precisely is non-trivial. The naive approach—pre-calculating per-vote rates—leads to stuck funds, unfairness for small participants, and operational issues.

#### The Problem with Pre-Calculation

**Rewards:**  
Traditional protocols pre-calculate: `rewardsPerVote = (poolRewards * 1e18) / totalVotes`

This is fundamentally flawed:
- If `poolRewards` is small relative to `totalVotes`, `rewardsPerVote` can floor to zero
- Small voters are zeroed out while large voters receive rounded-down values
- Increasing pool rewards isn't an option—they're financed by accrued verification fees

**Subsidies:**  
Pre-calculating `subsidyPerVote = subsidies / totalVotes` means small subsidies in high-vote epochs floor to zero, making them undistributable.

*Example:*
```
Assume: totalRewards=5, totalVotes=10
- User A with 3 votes: (3*5)/10 = 1 (floored from 1.5)
- User B with 1 vote: (1*5)/10 = 0 (floored from 0.5)

User B has no rewards to claim.
```

#### Our Solution: Proportional, On-Claim Calculation

We reject pre-calculation in favor of a proportional, on-claim approach:

- **No Pre-Calculation:** We do not store `rewardsPerVote` or `subsidyPerVote`
- **Direct Allocation:** On deposit, we simply set `totalRewards` or `totalSubsidies` if non-zero and there are votes
- **On-Claim Math:** All calculations performed at claim time:
  - Rewards: `userRewards = (userVotes * totalRewards) / totalVotes`
  - Subsidies: `poolSubsidies = (poolVotes * totalSubsidies) / totalVotes`

**Why This Works:**
- **No Stuck Funds:** Partial distribution always possible; residuals can be swept later
- **Per-Pool Isolation:** Zero-reward pools never block others
- **No Reverts for Small Amounts:** Tiny amounts handled gracefully
- **Simplicity & Gas Efficiency:** Fewer storage writes, cheaper execution

### Residuals Management

**What are residuals?**  
Small amounts left behind due to flooring in integer division. They are unavoidable but manageable.

**Sources of Residuals:**
1. Pool allocation: `poolSubsidies = (poolVotes × totalSubsidies) / totalVotes`
2. User rewards: `userRewards = (userVotes × poolRewards) / totalPoolVotes`
3. Delegate rewards: Multiple divisions compound rounding losses

**Management Strategy:**
- Track exact amounts distributed vs. allocated
- Residuals = allocated - claimed
- Admin sweeps residuals after delay period
- No distinction between "unclaimed" and "residuals" for simplicity

**During Epoch Finalization:**
```solidity
// Only allocate if result is non-zero
if(poolSubsidies > 0) { 
    epochPoolPtr.totalSubsidiesAllocated = poolSubsidies;
    poolPtr.totalSubsidiesAllocated += poolSubsidies;
}

// Only set rewards if pool has votes and rewards > 0
if(poolRewards > 0 && hasVotes) {
    epochPoolPtr.totalRewardsAllocated = poolRewards;
    poolPtr.totalRewardsAllocated += poolRewards;
}
```

**During Claims:**
- All calculations use integer division (rounded down)
- Every distributed amount is booked in `epoch.totalRewardsClaimed` / `epoch.totalSubsidiesClaimed`

**Unified Sweeping:**
- `withdrawUnclaimedRewards()` and `withdrawUnclaimedSubsidies()` sweep all leftovers after delay
- Result: `totalAllocated - totalClaimed` = true residuals + unclaimed

### Accurate Delegate Fee Application: Historical Fee Tracking

**The Challenge:**
Delegate fees can be updated at any epoch. If a delegate increases their fee in epoch N but a user claims for epoch N-2, what fee applies?

**The Solution: Epoch-Indexed Fee History**

```solidity
mapping(address => mapping(uint128 => uint128)) delegateHistoricalFeePcts;
```

**How It Works:**
1. When a delegate votes, `_validateDelegateAndRecordFee()` logs their current fee for that epoch
2. When rewards are claimed, the historical fee (not current) is applied
3. Fee increases are only activated after `FEE_INCREASE_DELAY_EPOCHS` passes
4. Fee decreases apply immediately and retroactively overwrite the current epoch's snapshot

### Delegated Reward Claiming: Per-Pool, Per-Delegate Tracking

**The `UserDelegateAccount` struct:**

```solidity
struct UserDelegateAccount {
    // Aggregate totals (accumulated during processing)
    uint128 totalGrossRewards;      // Sum of gross rewards across processed pools
    uint128 totalDelegateFees;      // Sum of delegate fees
    uint128 totalNetRewards;        // totalGrossRewards - totalDelegateFees
    
    // Aggregate claimed (updated during actual transfers)
    uint128 userClaimed;            // Total NET claimed by user
    uint128 delegateClaimed;        // Total FEES claimed by delegate
    
    // Per-pool tracking (for processing only)
    mapping(uint128 poolId => uint128 grossRewards) userPoolGrossRewards;
    mapping(uint128 poolId => bool) poolProcessed;
}
```

**Why per-pool tracking is essential:**
- Users may claim for the same delegate across different pools (multiple calls)
- Users may claim from different delegates with overlapping pools
- We must allow granular claims while preventing double-claiming

**The Solution:**
- Track `poolProcessed[poolId]` to prevent re-processing the same pool
- Track aggregate totals separately from per-call deltas
- Claiming is delta-based: `totalClaimable = totalNetRewards - userClaimed`

### Safe Down-casting in claimSubsidies

```solidity
uint128 poolAllocatedSubsidies = epochPools[epoch][poolId].totalSubsidiesAllocated;

(uint256 verifierAccruedSubsidies, uint256 poolAccruedSubsidies)
    = PAYMENTS_CONTROLLER.getVerifierAndPoolAccruedSubsidies(...);

uint256 ratio = (verifierAccruedSubsidies * 1E18) / poolAccruedSubsidies; 

uint128 subsidyReceivable = uint128((ratio * poolAllocatedSubsidies) / 1E18); 
```

**Why the downcast is safe:**

1. **Ratio is bounded to [0, 1E18]:**
   - `verifierAccruedSubsidies ≤ poolAccruedSubsidies` by definition
   - Therefore: `ratio ≤ 1E18`

2. **Result is bounded by `poolAllocatedSubsidies`:**
   - `subsidyReceivable = (ratio × poolAllocatedSubsidies) / 1E18 ≤ poolAllocatedSubsidies`

3. **`poolAllocatedSubsidies` is already uint128:**
   - Since `subsidyReceivable ≤ poolAllocatedSubsidies ≤ type(uint128).max`
   - The downcast **cannot overflow**

### Why uint128 Is Safe for Vote & Reward Accounting

**Token Economics Constraints:**
- MOCA Total Supply: 8.89 billion tokens (8.89 × 10⁹)
- With 18 decimals: 8.9 × 10²⁷ units
- uint128 maximum: 3.4 × 10³⁸

**Safety Margin:**
- Maximum voting power = Full supply locked = 8.9 × 10²⁷ units
- 11 orders of magnitude below uint128 max

**Epoch-Scoped vs. Long-Lived Accumulators:**
- Epoch-scoped fields (`Epoch.totalVotes`, `PoolEpoch.totalVotes`) reset each epoch
- Long-lived accumulators (`Pool.totalVotes`) grow by at most full-supply per epoch
- 50 years × 52 epochs ≈ 2,600 epochs → worst-case ≈ 2.3 × 10³¹, still 10⁷× under cap

**Conclusion:** uint128 is sound; overflow requires >10⁵× supply increase or centuries of max-supply voting.

### Overflow Analysis

**Potential overflow source:**
```solidity
uint256 delegatePoolRewards = (delegatePoolVotes * totalPoolRewards) / totalPoolVotes;
uint256 userGrossRewards = (userVotesAllocatedToDelegateForEpoch * delegatePoolRewards) / delegateTotalVotesForEpoch;
```

**Mathematical Analysis:**
- Maximum possible multiplication: 8.888 × 10²⁷ × 10,000 = 8.888 × 10³¹
- Safety margin: (1.16 × 10⁷⁷) / (8.888 × 10³¹) = 1.3 × 10⁴⁶

**Conclusion:** Integer overflow is mathematically impossible given MOCA's capped supply and fee percentage limits.

### Gas Optimization

The contract employs several gas optimization techniques:

1. **Batch Operations**: Multiple claims/votes in single transaction
2. **Storage Packing**: Using uint128 where possible
3. **Conditional Updates**: Only update storage when values change
4. **Memory Caching**: Cache storage pointers in loops
5. **`_mulDiv` helper**: Performs multiplication in uint256 space, downcasts after division

---

## Epoch State Lifecycle

The epoch lifecycle is controlled by five flags in the `Epoch` struct:

```lua
|        Flag              |           Set By                  | Purpose                                         |
|------------------------- |-----------------------------------|-------------------------------------------------|
| `isSubsidiesSet`         | `depositEpochSubsidies()`         | Blocks voting, signals epoch-end ops started     |
| `isFullyProcessed`       | `processEpochRewardsSubsidies()`  | All active pools have been processed             |
| `isEpochFinalized`       | `finalizeEpoch()`                 | Rewards deposited, claims open                   |
| `isRewardsWithdrawn`     | `withdrawUnclaimedRewards()`      | Blocks reward claims                             |
| `isSubsidiesWithdrawn`   | `withdrawUnclaimedSubsidies()`    | Blocks subsidy claims                            |
```
**Special Case: No Active Pools**

When `TOTAL_ACTIVE_POOLS == 0` in `depositEpochSubsidies()`:
- `isSubsidiesSet = true`
- `isFullyProcessed = true`
- `isEpochFinalized = true`
- `totalActivePools = 0` and `poolsProcessed = 0`

This skips `processEpochRewardsSubsidies()` and `finalizeEpoch()` calls entirely.

---

## Kill Switch & Operational Dependencies

### Sequential Cron Pipeline

Each epoch relies on three privileged calls in exact order:
1. `depositEpochSubsidies`
2. `processEpochRewardsSubsidies` (may be called multiple times)
3. `finalizeEpoch`

Missing or reverting any step blocks the epoch indefinitely. The only escape hatch is `forceFinalizeEpoch()`.

### forceFinalizeEpoch Impact

- `DEFAULT_ADMIN_ROLE` call to `forceFinalizeEpoch(epoch, blockClaims)`
- If `blockClaims = true`: marks rewards and subsidies as "withdrawn" without transferring tokens
- Users can no longer claim, yet balances remain in contract until manually swept

### Freeze + Emergency Exit

- Once `freeze()` is invoked (requires pause first), only `emergencyExit()` can be called
- `emergencyExit()` unconditionally transfers ALL esMOCA + native MOCA to treasury
- Disregards all outstanding claims

### Operational Risk

- Compromising or misconfiguring any role (cron admin, monitor, default admin, emergency handler) can halt rewards, confiscate balances, or drain the contract
- None of these functions are timelocked or multi-sig-gated by default in the contract itself

### Recommended Operator Practice

1. Run cron pipeline via monitored automation with replay protection
2. Require timelock + multi-sig approval before invoking `forceFinalizeEpoch`, `freeze`, or `emergencyExit`
3. Keep high-frequency calls (cron, monitor) on separately permissioned keys with revocation procedures
4. Schedule periodic `VotingEscrowMoca.updateAccountsAndPendingDeltas` / `updateDelegatePairsAndPendingDeltas` jobs so claims cannot be bricked by stale checkpoints

---

## Security & Risk Management

### Access Control

The contract implements role-based access control:

|            Role                  | Capabilities                                         |
|:--------------------------------:|:----------------------------------------------------|
| **DEFAULT_ADMIN_ROLE**           | Unpause, freeze, force finalize, manage other roles |
| **VOTING_CONTROLLER_ADMIN_ROLE** | Create/remove pools, set protocol parameters        |
| **CRON_JOB_ROLE**                | Deposit subsidies, process pools, finalize epochs   |
| **CRON_JOB_ADMIN_ROLE**          | Manage CRON_JOB_ROLE members                        |
| **MONITOR_ROLE**                 | Pause contract                                      |
| **MONITOR_ADMIN_ROLE**           | Manage MONITOR_ROLE members                         |
| **ASSET_MANAGER_ROLE**           | Withdraw unclaimed rewards/subsidies/fees           |
| **EMERGENCY_EXIT_HANDLER_ROLE**  | Execute emergency exit when frozen                  |

### Role Hierarchy

```
DEFAULT_ADMIN_ROLE
├── VOTING_CONTROLLER_ADMIN_ROLE
├── EMERGENCY_EXIT_HANDLER_ROLE
├── MONITOR_ADMIN_ROLE
│   └── MONITOR_ROLE
└── CRON_JOB_ADMIN_ROLE
    └── CRON_JOB_ROLE
```

### View Functions

The contract provides preview functions for off-chain calculation:
- `viewClaimablePersonalRewards()` - Preview personal voting rewards
- `viewClaimableDelegatedRewards()` - Preview delegated rewards (net and fees)
- `viewClaimableDelegationFees()` - Preview claimable fees for delegates
- `viewClaimableSubsidies()` - Preview verifier subsidies
