# VotingController Contract 

## Overview

VotingController is the governance hub of the protocol's voting ecosystem:
- Manages voting, reward distribution, and subsidy payments
- Enables users to vote on credential pools, delegates to manage voting on behalf of others, and verifiers to receive subsidies for their services
- Operates entirely on-chain with no reliance on external relayers

Think of VotingController as a sophisticated voting booth combined with a rewards distribution center; users cast votes to direct protocol resources, earn rewards for participation, and delegates can offer  voting services for a fee.

## Table of Contents

1. [Core Concepts](#core-concepts)
   - [What is VotingController?](#what-is-votingcontroller)
   - [Key Participants](#key-participants)
   - [The Epoch System](#the-epoch-system)
2. [Architecture Overview](#architecture-overview)
   - [Dual-Accounting Model](#dual-accounting-model)
   - [Integration Points](#integration-points)
3. [Key Features](#key-features)
   - [Voting Mechanics](#voting-mechanics)
   - [Delegation System](#delegation-system)
   - [Rewards & Subsidies](#rewards--subsidies)
4. [Contract Walkthrough](#contract-walkthrough)
   - [State Variables](#state-variables)
   - [Core Functions](#core-functions)
5. [User Flows](#user-flows)
   - [Voting Flow](#voting-flow)
   - [Delegation Flow](#delegation-flow)
   - [Claiming Rewards](#claiming-rewards)
6. [End of Epoch Execution Flows](#end-of-epoch-execution-flows)
7. [Technical Deep Dive](#technical-deep-dive)
   - [Rewards & Subsidies: Optimal Distribution](#rewards--subsidies-optimal-distribution)
   - [Residuals Management](#residuals-management)
   - [Historical Fee Tracking](#accurate-delegate-fee-application-historical-fee-tracking)
   - [Delegated Reward Claiming](#delegated-reward-claiming-per-pool-per-delegate-tracking)
   - [Safe Downcasting in claimSubsidies](#safe-downcasting-in-claimsubsidies)
   - [Why uint128 Is Safe](#why-uint128-is-safe-for-vote--reward-accounting)
   - [Overflow Analysis](#overflow-analysis)
   - [Gas Optimization](#gas-optimization)
8. [Epoch State Lifecycle](#epoch-state-lifecycle)
9. [Kill Switch & Operational Dependencies](#kill-switch--operational-dependencies)
10. [Security & Risk Management](#security--risk-management)

---

## Core Concepts

### What is VotingController

VotingController is a smart contract that orchestrates the protocol's governance through a vote-to-earn mechanism. It allows token holders to:
- Direct protocol resources by voting on credential pools
- Earn rewards proportional to their voting participation
- Delegate voting power to professional voters (delegates)
- Distribute subsidies to verifiers

### Key Participants

**1. Voters**
- Have voting power from creating locks on VotingEscrowMoca contract
- Vote on credential pools to direct protocol resources
- Earn esMOCA rewards based on future verification fees

**2. Delegates**
- Professional voters who manage voting on behalf of others
- Charge fees (as a percentage) for their services
- Must register and pay a one-time registration fee (in native MOCA)

**3. Verifiers (defined on PaymentsController)**
- Service providers who verify credentials
- Receive subsidies based on their activity and pool votes
- Claim subsidies after epoch finalization

**4. Cronjob**
- Manage epoch transitions


### Voting: Pool, Rewards and Subsidies

Each epoch has configurable reward and subsidy allocations:

- Both rewards and subsidies are discretionary; either or both can be 0 for any epoch
- These are set at the end of the epoch after voting has ended; not before. 
- Only pools with votes receive allocations
- All distributions are paid in esMOCA

**Pool & Subsidies:**
- A pool is a collection of schemas, as defined on PaymentsController. 
- Verifiers that accrued verification payments in schemas associated with an active pool are eligible.
- Subsidies for each pool is proportionally split across the verifiers' based on: `[verifierAccruedSubsidies / poolAccruedSubsidies] * poolAllocatedSubsidies`
- `verifierAccruedSubsidies` & `poolAccruedSubsidies` are obtained from referencing `PaymentsController.getVerifierAndPoolAccruedSubsidies()`
- Requires correct `poolId` associations on PaymentsController

**Voting Rewards [Personal]:**
- Voters that voted on active pools which have rewards allocated will receive rewards, proportional to their voting power bases on the total pool votes
- Calculation: `[userVotes / poolTotalVotes] * poolAllocatedRewards`

**Voting Rewards [Delegated]:**
- Delegates earn rewards the same way as personal voters.
- Since these rewards are earned via delegated voting power [via delegating locks on veMoca], for each pool rewards are proportionally distributed as such:
- Delegate's share: `(delegateVotes / poolTotalVotes) × poolAllocatedRewards`
- User's gross share: `(userDelegatedVP / delegateTotalVP) × delegatePoolRewards`
- A haircut is applied to users' delegated rewards, in the form of a delegation fee.
- This fee is paid out to delegates for their service.
- Users receive net rewards: `gross - fee`

**What is the point of voting?**
- users vote to express their view on which pools (group of schemas), should be incentivized with subsidies
- in this manner, voting directs the distribution of subsidies
- by participating in voting, the users earn rewards
- however, ultimately distribution is discretionary 

### The Epoch System

The protocol operates in fixed time periods called "epochs":
- An Epoch is **14 days**
- Each epoch represents a voting and reward cycle
- Epochs have clear start/end boundaries for fair accounting
- All rewards and subsidies are calculated per epoch


---

## Architecture Overview

### Dual-Accounting Model

VotingController implements a dual-accounting system where every address maintains two separate accounts:

**Personal Account**: Tracks direct voting activity
- Records votes cast with user's own veMOCA
- Accumulates rewards from personal voting

**Delegate Account**: Tracks delegated voting activity
- Records votes cast with delegated veMOCA from others
- Accumulates gross rewards and fees earned as a delegate

This design allows any address to seamlessly switch between being a voter and a delegate without separate contracts or complex state management.

### Integration Points

```
┌─────────────────────┐
│ VotingEscrowMoca    │ ◄── Provides voting power (veMOCA)
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│ VotingController    │ ◄── Central voting & distribution hub
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│ PaymentsController  │ ◄── Tracks verification fees & subsidies accrued
└─────────────────────┘
```

---

## Key Features

### Voting Mechanics

**Forward-Decay Voting Power**
- Voting power is calculated at the end of the current epoch via `VEMOCA.balanceAtEpochEnd()`
- Ignores time-based decay within an epoch, so that users need not rush to vote
- Ensures fair representation across the epoch

**Multi-Pool Voting**
- Users can vote on multiple pools in a single transaction
- Vote migration allowed within the current epoch without decay penalty
- Cannot vote once epoch state transitions from `Voting` (end-of-epoch operations underway)

**Pool IDs**
- Pools are identified by sequential `uint128` IDs starting from **1**
- Batch creation via `createPools(count)` creates `count` consecutive pools
- Maximum 10 pools per `createPools` call; no explicit limit on `removePools`

### Delegation System

**On-Chain Delegation**
- Fully on-chain delegation with no relayer dependencies
- Delegates set fee percentages (e.g., 10% of rewards)
- Fee increases have mandatory delay (protection for users)
- Fee decreases apply immediately (user-friendly)

**Historical Fee Tracking**
- Fees are logged per epoch 
- Users pay the fee that was active when rewards were earned
- Prevents retroactive fee changes from affecting past epochs

### Rewards & Subsidies

**Voting Rewards (for Voters)**
- Treasury-funded incentives for verifiers
- Distributed proportionally: `userRewards = (userVotes × poolRewards) / totalPoolVotes`
- Claimed after epoch finalization

**Verification Subsidies (for Verifiers)**
- Funded by verification fees from PaymentsController
- Proportional to verifier activity and pool votes
- Claimed after epoch finalization

---

## Contract Walkthrough

### State Variables

#### Global Counters
```solidity
uint128 public CURRENT_EPOCH_TO_FINALIZE;    // Next epoch awaiting finalization

uint128 public TOTAL_POOLS_CREATED;          // Total pools ever created
uint128 public TOTAL_ACTIVE_POOLS;           // Currently active pool count

uint128 public TOTAL_SUBSIDIES_DEPOSITED;    // Total subsidies ever deposited
uint128 public TOTAL_SUBSIDIES_CLAIMED;      // Total subsidies ever claimed

uint128 public TOTAL_REWARDS_DEPOSITED;      // Total rewards ever deposited
uint128 public TOTAL_REWARDS_CLAIMED;        // Total rewards ever claimed
```

#### Configuration Parameters
```solidity
uint128 public DELEGATE_REGISTRATION_FEE;    // Fee to register as delegate (in native MOCA)
uint128 public MAX_DELEGATE_FEE_PCT;         // Maximum delegate fee (10000 = 100%)
uint128 public FEE_INCREASE_DELAY_EPOCHS;    // Delay for fee increases (in epochs)
uint128 public UNCLAIMED_DELAY_EPOCHS;       // Delay before unclaimed funds can be swept
uint128 public MOCA_TRANSFER_GAS_LIMIT;      // Gas limit for native MOCA transfers
```

#### Registration Fee Tracking
```solidity
uint128 public TOTAL_REGISTRATION_FEES_COLLECTED;    
uint128 public TOTAL_REGISTRATION_FEES_CLAIMED;
```

#### Core Mappings

**Epoch & Pool Data**
```solidity
mapping(uint128 epochNum => DataTypes.Epoch epoch) public epochs;    
mapping(uint128 poolId => DataTypes.Pool pool) public pools;
mapping(uint128 epochNum => mapping(uint128 poolId => DataTypes.PoolEpoch poolEpoch)) public epochPools;
```

**User & Delegate Accounting**
```solidity
// Personal voting
mapping(uint128 epochNum => mapping(address userAddr => DataTypes.Account userAccount)) public usersEpochData;
mapping(uint128 epochNum => mapping(uint128 poolId => mapping(address user => DataTypes.Account userAccount))) public usersEpochPoolData;

// Delegated voting
mapping(uint128 epochNum => mapping(address delegateAddr => DataTypes.Account delegate)) public delegateEpochData;
mapping(uint128 epochNum => mapping(uint128 poolId => mapping(address delegate => DataTypes.Account delegateAccount))) public delegatesEpochPoolData;
```

**User-Delegate Pair Tracking**
```solidity
// For delegated reward claiming
mapping(uint128 epochNum => mapping(address user => mapping(address delegate => DataTypes.UserDelegateAccount userDelegateAccount))) public userDelegateAccounts;
```

**Delegate Data**
```solidity
mapping(address delegateAddr => DataTypes.Delegate delegate) public delegates;     
mapping(address delegate => mapping(uint128 epoch => uint128 currentFeePct)) public delegateHistoricalFeePcts;
```

**Verifier Subsidy Tracking**
```solidity
mapping(address verifier => uint128 totalSubsidies) public verifierSubsidies;                  
mapping(uint128 epoch => mapping(address verifier => DataTypes.VerifierEpoch verifierEpochData)) public verifierEpochData;
mapping(uint128 epoch => mapping(uint128 poolId => mapping(address verifier => uint128 totalSubsidies))) public verifierEpochPoolSubsidies;

// VerifierEpoch struct
struct VerifierEpoch {
    bool isBlocked;                  // Blocks claims if verifier fails checks
    uint128 totalSubsidiesClaimed;   // Total subsidies claimed by verifier for this epoch
}
```

- `isBlocked`: we might need to block specific verifiers from claiming subsidies, as PaymentsController contract or specific actors might be misbehaving for that epoch.
- `verifierSubsidies` is non-essential and included as a simple tracker.
- both `verifierEpochData` and `verifierEpochPoolSubsidies` are essential.

### Core Functions

#### Voting Functions

**`vote(uint128[] poolIds, uint128[] poolVotes, bool isDelegated)`**
- Cast votes for one or more pools
- `isDelegated`: true = use delegated voting power, false = use personal power
- Validates voting power availability via `VEMOCA.balanceAtEpochEnd()`
- Updates all relevant vote tallies
- Cannot be called once epoch state is no longer `Voting`

**`migrateVotes(uint128[] srcPoolIds, uint128[] dstPoolIds, uint128[] votesToMigrate, bool isDelegated)`**
- Move votes between pools within current epoch
- Can migrate from inactive to active pools (but not vice versa)
- Maintains vote conservation (no creation/destruction)
- Updates pool-level vote totals without affecting account's total votes spent

> No unvote function, as its pointless to remove votes from an epoch, as there is no penalties associated with such an action.

#### Delegation Functions

**`registerAsDelegate(uint128 feePct)`**
- Register as a delegate with specified fee percentage
- Requires payment of `DELEGATE_REGISTRATION_FEE` in native MOCA
- Activates delegate status in VotingEscrowMoca via `VEMOCA.delegateRegistrationStatus()`

**`updateDelegateFee(uint128 newFeePct)`**
- Modify delegate fee percentage
- Increases: scheduled for `currentEpoch + FEE_INCREASE_DELAY_EPOCHS`
- Decreases: apply immediately and retroactively for current epoch

**`unregisterAsDelegate()`**
- Cannot unregister if delegate has active votes in current epoch
- Registration fee is non-refundable
- Removes delegate status

#### Claiming Functions

**`claimPersonalRewards(uint128 epoch, uint128[] poolIds)`**
- Claim rewards from personal voting
- Must wait for epoch finalization
- Rewards paid in esMOCA
- Prevents double-claiming via `userPoolAccountPtr.totalRewards` check

**`claimDelegatedRewards(uint128 epoch, address[] delegateList, uint128[][] poolIds)`**
- Claim net rewards from delegated voting across multiple delegates
- Automatically deducts delegate fees based on historical rates
- Supports batch claiming for gas efficiency

**`claimDelegationFees(uint128 epoch, address[] delegators, uint128[][] poolIds)`**
- Delegates claim their earned fees from multiple delegators
- Processes multiple delegators in one transaction
- Uses historical fee rates (not current rates)

*Note:*
- `claimDelegatedRewards()` and `claimDelegationFees()` are complementary functions for delegated voting
- Either party can trigger the reward/fee calculation and claim their share independently

**`claimSubsidies(uint128 epoch, address verifier, uint128[] poolIds)`**
- Verifiers claim esMOCA subsidies for their pools in a finalized epoch
- Only the registered asset address for the verifier can call (verified by PaymentsController)
- Verifier must not be blocked (checked via `verifierEpochData[epoch][verifier].isBlocked`)
- Calculates each pool's subsidy share based on verifier's activity ratio
- Prevents double-claims with per-pool tracking

#### Pool Management (VotingControllerAdmin Role)

**`createPools(uint128 count)`**
- Creates multiple voting pools in a single transaction
- Sequential IDs from `TOTAL_POOLS_CREATED + 1` to `TOTAL_POOLS_CREATED + count`
- Maximum 10 pools per call
- Blocked during active epoch finalization (must be in `Voting` state)

**`removePools(uint128[] poolIds)`**
- Removes multiple pools from active voting
- Marks pools as inactive; they won't receive allocations during processing

*Impact of removing pools mid-epoch:*
- Users who voted for removed pools can migrate their votes to active pools
- If not migrated: rewards for those votes are lost (pool becomes inactive, no allocations processed)

#### Epoch Management (CronJob Role)

**`endEpoch()`**
- Step 1: Ends the current epoch and transitions it to the `Ended` state
- Must be called after the epoch's full duration has passed
- Snapshots `TOTAL_ACTIVE_POOLS` for the epoch
- If no active pools: instantly finalizes the epoch and advances to next

**`processVerifierChecks(bool allCleared, address[] verifiers)`**
- Step 2: Processes verifier checks and transitions to `Verified` state
- Can be called multiple times to process verifiers in batches
- Blocks specified verifiers from claiming subsidies via `isBlocked` flag
- Call with `allCleared = true` to complete and transition state

**`processRewardsAndSubsidies(uint128[] poolIds, uint128[] rewards, uint128[] subsidies)`**
- Step 3: Allocates rewards and subsidies for specified pools
- Each pool can only be processed once per epoch
- Transitions to `Processed` state when all active pools are processed
- Can be called multiple times to process all pools in batches

**`finalizeEpoch()`**
- Step 4: Transfers rewards and subsidies from treasury to contract
- Transitions to `Finalized` state
- Opens claiming for users and verifiers
- Advances `CURRENT_EPOCH_TO_FINALIZE` to next epoch

**`forceFinalizeEpoch()`**
- Emergency function to force finalize an epoch
- Zeroes out all reward and subsidy allocations (blocks claims)
- Transitions to `ForceFinalized` state
- Only callable by `DEFAULT_ADMIN_ROLE`

#### Asset Recovery Functions (AssetManager Role)

**`withdrawUnclaimedRewards(uint128 epoch)`**
- Sweeps unclaimed rewards after `UNCLAIMED_DELAY_EPOCHS`
- Sets `totalRewardsWithdrawn` to block future claims
- Transfers to treasury

**`withdrawUnclaimedSubsidies(uint128 epoch)`**
- Sweeps unclaimed subsidies after `UNCLAIMED_DELAY_EPOCHS`
- Sets `totalSubsidiesWithdrawn` to block future claims
- Transfers to treasury

**`withdrawRegistrationFees()`**
- Withdraws collected delegate registration fees (native MOCA)
- Uses `_transferMocaAndWrapIfFailWithGasLimit` for safe transfer

#### Configuration Functions (VotingControllerAdmin Role)

- `setVotingControllerTreasury(address)` - Update treasury address
- `setDelegateRegistrationFee(uint128)` - Update registration fee (0 allowed)
- `setMaxDelegateFeePct(uint128)` - Update max delegate fee percentage
- `setFeeIncreaseDelayEpochs(uint128)` - Update fee increase delay
- `setUnclaimedDelay(uint128)` - Update unclaimed sweep delay
- `setMocaTransferGasLimit(uint128)` - Update gas limit for MOCA transfers

#### Risk Management Functions

**`pause()` (Monitor Role)**
- Immediately halts all user operations

**`unpause()` (DEFAULT_ADMIN_ROLE)**
- Resumes normal operations after pause
- Cannot be called if contract is frozen

**`freeze()` (DEFAULT_ADMIN_ROLE)**
- Permanently disables the contract (one-way)
- Enables emergency asset recovery

**`emergencyExit()` (EmergencyExitHandler Role)**
- Recovers all contract-held assets when frozen
- Transfers esMOCA and native MOCA to treasury
- Disregards all outstanding claims

---

## User Flows

### Voting Flow

1. User holds veMOCA (from VotingEscrowMoca)
2. User calls `vote()` with pool selections
3. Contract validates available voting power at epoch end
4. Votes recorded for current epoch
5. After epoch is finalized, user can claim rewards

### Delegation Flow

**For Delegators:**
1. User delegates veMOCA to registered delegate (via VotingEscrowMoca)
2. Delegate votes on user's behalf
3. User claims net rewards (gross minus delegate fee) via `claimDelegatedRewards()`

**For Delegates:**
1. Register as delegate via `registerAsDelegate()` with fee percentage
2. Receive delegated veMOCA from users
3. Vote using aggregated delegated power
4. Claim fees from delegator rewards via `claimDelegationFees()`

### Claiming Rewards

The claiming process follows strict epoch boundaries:

1. **Epoch N**: Users vote on pools
3. **End of Epoch N**: Admin finalizes epoch with rewards & subsidies
4. **After finalization**: Users & verifiers claim their proportional rewards & subsidies

---

## End of Epoch Execution Flows

When an epoch ends, critical operations must occur in a specific order:

### Step 1: End Epoch

**Function:** `endEpoch()`  
**Caller:** CRON_JOB_ROLE  
**When:** After epoch's full duration has passed

- Validates epoch is in `Voting` state
- Snapshots `TOTAL_ACTIVE_POOLS` to `epoch.totalActivePools`
- Transitions epoch to `Ended` state
- **Edge case**: If `TOTAL_ACTIVE_POOLS == 0`, instantly transitions to `Finalized` and advances to next epoch

### Step 2: Process Verifier Checks

**Function:** `processVerifierChecks(bool allCleared, address[] verifiers)`  
**Caller:** CRON_JOB_ROLE  
**When:** After epoch ends

- Can be called multiple times to process verifiers in batches
- Marks specified verifiers as `isBlocked = true` to prevent subsidy claims
- Call with `allCleared = true` to transition to `Verified` state
- Emits `VerifiersClaimsBlocked` for blocked verifiers

### Step 3: Process Rewards & Subsidies

**Function:** `processRewardsAndSubsidies(uint128[] poolIds, uint128[] rewards, uint128[] subsidies)`
**Caller:** CRON_JOB_ROLE
**When:** After epoch is verified

For each pool:
- Validates pool is active and not already processed
- Allocates rewards and subsidies from input arrays
- Marks pool as `isProcessed = true`
- Increments `poolsProcessed` counter

When all pools processed: transitions to `Processed` state

### Step 4: Finalize Epoch

**Function:** `finalizeEpoch()`  
**Caller:** CRON_JOB_ROLE  
**When:** After all pools are processed

- Transfers total rewards + subsidies from treasury to contract [require esMoca approve allowance to be set]
- Transitions to `Finalized` state
- Advances `CURRENT_EPOCH_TO_FINALIZE` to next epoch
- Emits `EpochFinalized` event

### Step 5: Claims Open

After finalization, users and verifiers can claim:
- **Personal rewards**: `claimPersonalRewards()`
- **Delegated rewards**: `claimDelegatedRewards()` / `claimDelegationFees()`
- **Verifier subsidies**: `claimSubsidies()` (blocked verifiers cannot claim)

### Post-Epoch Cleanup

After `UNCLAIMED_DELAY_EPOCHS`:
- `withdrawUnclaimedRewards()` - Recovers unclaimed voter rewards
- `withdrawUnclaimedSubsidies()` - Recovers unclaimed verifier subsidies

### Timeline Example

For 14-day epochs:
- **Day 0-14**: Epoch N active (voting occurs)
- **Day 14**: Epoch N ends
- **Day 14-15**: Admin ends epoch → verifier checks → processes pools → finalizes
- **Day 15+**: Claims open for epoch N
- **Day 98+**: Unclaimed funds can be swept (assuming 6 epoch delay)

---

## Technical Deep Dive

### Rewards & Subsidies: Optimal Distribution

Distributing rewards and subsidies fairly and precisely is non-trivial.
The naive approach—pre-calculating per-vote rates—leads to stuck funds, unfairness for small participants, and operational issues.

#### The Problem with Pre-Calculation

**Rewards:**  
Traditional pre-calculation approach: `rewardsPerVote = (poolRewards * 1e18) / totalVotes`

This is fundamentally flawed:
- If `poolRewards` is small relative to `totalVotes`, `rewardsPerVote` can floor to zero
- Small voters are zeroed out while large voters receive rounded-down values
- Increasing pool rewards isn't an option—they're financed by accrued verification fees

**Subsidies:**  
Pre-calculating `subsidyPerVote = subsidies / totalVotes` means small subsidies in high-vote epochs floor to zero, making them undistributable.

*Example:*
```
Assume: totalRewards=5, totalVotes=10
- User A with 3 votes: (3*5)/10 = 1 (floored from 1.5)
- User B with 1 vote: (1*5)/10 = 0 (floored from 0.5)

User B has no rewards to claim.
```

#### Our Solution: Proportional, On-Claim Calculation

We reject pre-calculation in favor of a proportional, on-claim approach:

- **No Pre-Calculation:** We do not store `rewardsPerVote` or `subsidyPerVote`
- **Direct Allocation:** On deposit, we simply set `totalRewards` or `totalSubsidies` if non-zero and there are votes
- **On-Claim Math:** All calculations performed at claim time:
  - Rewards: `userRewards = (userVotes * totalRewards) / totalVotes`
  - Subsidies: `poolSubsidies = (poolVotes * totalSubsidies) / totalVotes`

**Why This Works:**
- **No Stuck Funds:** Partial distribution always possible; residuals can be swept later
- **Per-Pool Isolation:** Zero-reward pools never block others
- **No Reverts for Small Amounts:** Tiny amounts handled gracefully

### Residuals Management

**What are residuals?**  
Small amounts left behind due to flooring in integer division. They are unavoidable but manageable.

**Sources of Residuals:**
1. Pool allocation: `poolSubsidies = (poolVotes × totalSubsidies) / totalVotes`
2. User rewards: `userRewards = (userVotes × poolRewards) / totalPoolVotes`
3. Delegate rewards: Multiple divisions compound rounding losses

**Management Strategy:**
- Track exact amounts distributed vs. allocated
- Residuals = allocated - claimed
- Admin sweeps residuals after delay period
- No distinction between "unclaimed" and "residuals" for simplicity

**During Epoch Finalization:**
```solidity
// Only allocate if result is non-zero
if(poolSubsidies > 0) { 
    epochPoolPtr.totalSubsidiesAllocated = poolSubsidies;
    poolPtr.totalSubsidiesAllocated += poolSubsidies;
}

// Only set rewards if pool has votes and rewards > 0
if(poolRewards > 0 && hasVotes) {
    epochPoolPtr.totalRewardsAllocated = poolRewards;
    poolPtr.totalRewardsAllocated += poolRewards;
}
```

**During Claims:**
- All calculations use integer division (rounded down)
- Every distributed amount is booked in `epoch.totalRewardsClaimed` / `epoch.totalSubsidiesClaimed`

**Unified Sweeping:**
- `withdrawUnclaimedRewards()` and `withdrawUnclaimedSubsidies()` sweep all leftovers after delay
- Result: `totalAllocated - totalClaimed` = true residuals + unclaimed

### Accurate Delegate Fee Application: Historical Fee Tracking

**The Challenge:**
Delegate fees can be updated at any epoch. If a delegate increases their fee in epoch N but a user claims for epoch N-2, what fee applies?

**The Solution: Epoch-Indexed Fee History**

```solidity
mapping(address => mapping(uint128 => uint128)) delegateHistoricalFeePcts;
```

**How It Works:**
1. When a delegate votes, `_validateDelegateAndRecordFee()` logs their current fee for that epoch
2. When rewards are claimed, the historical fee (not current) is applied
3. Fee increases are only activated after `FEE_INCREASE_DELAY_EPOCHS` passes
4. Fee decreases apply immediately and retroactively overwrite the current epoch's snapshot

### Delegated Reward Claiming: Per-Pool, Per-Delegate Tracking

**The `UserDelegateAccount` struct:**

```solidity
struct UserDelegateAccount {
    // Aggregate totals (accumulated during processing)
    uint128 totalGrossRewards;      // Sum of gross rewards across processed pools
    uint128 totalDelegateFees;      // Sum of delegate fees
    uint128 totalNetRewards;        // totalGrossRewards - totalDelegateFees
    
    // Aggregate claimed (updated during actual transfers)
    uint128 userClaimed;            // Total NET claimed by user
    uint128 delegateClaimed;        // Total FEES claimed by delegate
    
    // Per-pool tracking (for processing only)
    mapping(uint128 poolId => uint128 grossRewards) userPoolGrossRewards;
}
```

**Why per-pool tracking is essential:**
- Users may claim for the same delegate across different pools (multiple calls)
- Users may claim from different delegates with overlapping pools
- We must allow granular claims while preventing double-claiming

**The Solution:**
- Track `userPoolGrossRewards[poolId]` to prevent re-processing the same pool (non-zero = already processed)
- Track aggregate totals separately from per-call deltas
- Claiming is delta-based: `totalClaimable = totalNetRewards - userClaimed`

### Safe Down-casting in claimSubsidies

```solidity
uint128 poolAllocatedSubsidies = epochPools[epoch][poolId].totalSubsidiesAllocated;

(uint256 verifierAccruedSubsidies, uint256 poolAccruedSubsidies)
    = PAYMENTS_CONTROLLER.getVerifierAndPoolAccruedSubsidies(...);

uint256 ratio = (verifierAccruedSubsidies * 1E18) / poolAccruedSubsidies; 

uint128 subsidyReceivable = uint128((ratio * poolAllocatedSubsidies) / 1E18); 
```

**Why the downcast is safe:**

1. **Ratio is bounded to [0, 1E18]:**
   - `verifierAccruedSubsidies ≤ poolAccruedSubsidies` by definition
   - Therefore: `ratio ≤ 1E18`

2. **Result is bounded by `poolAllocatedSubsidies`:**
   - `subsidyReceivable = (ratio × poolAllocatedSubsidies) / 1E18 ≤ poolAllocatedSubsidies`

3. **`poolAllocatedSubsidies` is already uint128:**
   - Since `subsidyReceivable ≤ poolAllocatedSubsidies ≤ type(uint128).max`
   - The downcast **cannot overflow**

### Why uint128 Is Safe for Vote & Reward Accounting

**Token Economics Constraints:**
- MOCA Total Supply: 8.89 billion tokens (8.89 × 10⁹)
- With 18 decimals: 8.9 × 10²⁷ units
- uint128 maximum: 3.4 × 10³⁸

**Safety Margin:**
- Maximum voting power = Full supply locked = 8.9 × 10²⁷ units
- 11 orders of magnitude below uint128 max

**Epoch-Scoped vs. Long-Lived Accumulators:**
- Epoch-scoped fields (`PoolEpoch.totalVotes`) reset each epoch
- Long-lived accumulators (`Pool.totalVotes`) grow by at most full-supply per epoch
- 50 years × 26 epochs/year ≈ 1,300 epochs → worst-case ≈ 1.2 × 10³¹, still 10⁷× under cap

**Conclusion:** uint128 is sound; overflow requires >10⁵× supply increase or centuries of max-supply voting.

### Overflow Analysis

**Potential overflow source:**
```solidity
uint256 delegatePoolRewards = (delegatePoolVotes * totalPoolRewards) / totalPoolVotes;
uint256 userGrossRewards = (userVotesAllocatedToDelegateForEpoch * delegatePoolRewards) / delegateTotalVotesForEpoch;
```

**Mathematical Analysis:**
- Maximum possible multiplication: 8.888 × 10²⁷ × 10,000 = 8.888 × 10³¹
- Safety margin: (1.16 × 10⁷⁷) / (8.888 × 10³¹) = 1.3 × 10⁴⁶

**Conclusion:** Integer overflow is mathematically impossible given MOCA's capped supply and fee percentage limits.

### Gas Optimization

The contract employs several gas optimization techniques:

1. **Batch Operations**: Multiple claims/votes in single transaction
2. **Storage Packing**: Using uint128 where possible
3. **Conditional Updates**: Only update storage when values change
4. **Memory Caching**: Cache storage pointers in loops
5. **`_mulDiv` helper**: Performs multiplication in uint256 space, downcasts after division

---

## Epoch State Lifecycle

The epoch lifecycle is controlled by an `EpochState` enum:

```solidity
enum EpochState {
    Voting,         // 0 - Default state, voting open, pools can be created/removed
    Ended,          // 1 - Voting closed, end-of-epoch processing started
    Verified,       // 2 - Verifier checks completed, awaiting rewards & subsidies allocation
    Processed,      // 3 - All pools processed, awaiting finalization
    Finalized,      // 4 - Complete, claims open
    ForceFinalized  // 5 - Emergency finalization, claims blocked
}
```

```lua
|        State             |           Set By                  | Purpose                                         |
|------------------------- |-----------------------------------|-------------------------------------------------|
| `Voting`                 | Default / Constructor             | Voting open, epoch in progress                  |
| `Ended`                  | `endEpoch()`                      | Voting closed, processing started               |
| `Verified`               | `processVerifierChecks()`         | Verifier checks done, awaiting pool processing  |
| `Processed`              | `processRewardsAndSubsidies()`    | All pools processed, awaiting finalization      |
| `Finalized`              | `finalizeEpoch()`                 | Claims open for rewards and subsidies           |
| `ForceFinalized`         | `forceFinalizeEpoch()`            | Emergency close, claims blocked                 |
```

**Additional Epoch Fields for Claim Control:**
- `totalRewardsWithdrawn` - Set by `withdrawUnclaimedRewards()`, blocks reward claims
- `totalSubsidiesWithdrawn` - Set by `withdrawUnclaimedSubsidies()`, blocks subsidy claims

**Special Case: No Active Pools**

When `TOTAL_ACTIVE_POOLS == 0` in `endEpoch()`:
- State instantly transitions to `Finalized`
- `CURRENT_EPOCH_TO_FINALIZE` advances to next epoch
- Skips `processVerifierChecks()`, `processRewardsAndSubsidies()`, and `finalizeEpoch()` calls entirely

---

## Kill Switch & Operational Dependencies

### Sequential Cron Pipeline

Each epoch relies on four privileged calls in exact order:
1. `endEpoch()` - Transitions to `Ended` state
2. `processVerifierChecks()` - Transitions to `Verified` state (may be called multiple times)
3. `processRewardsAndSubsidies()` - Transitions to `Processed` state (may be called multiple times)
4. `finalizeEpoch()` - Transitions to `Finalized` state

If any step is incorrectly executed, the only escape hatch is `forceFinalizeEpoch()`.

### forceFinalizeEpoch Impact

- `DEFAULT_ADMIN_ROLE` call to `forceFinalizeEpoch()`
- Zeroes out all reward and subsidy allocations
- Transitions to `ForceFinalized` state (claims blocked by design—no allocations)
- Users cannot claim, rewards/subsidies must be distributed by alternate means.

### Freeze + Emergency Exit

- Once `freeze()` is invoked (requires pause first), only `emergencyExit()` can be called
- `emergencyExit()` unconditionally transfers ALL esMOCA + native MOCA to treasury
- Disregards all outstanding claims

### Recommended Operator Practice

1. Run cron pipeline via monitored automation
2. Keep high-frequency calls (cron, monitor) on separately permissioned keys with revocation procedures
3. Schedule periodic `VotingEscrowMoca.updateAccountsAndPendingDeltas()` / `updateDelegatePairsAndPendingDeltas()` jobs so claims cannot be bricked by stale checkpoints
4. Monitor `processVerifierChecks()` to ensure verifier blocking is executed correctly before pool processing
5. Monitor Payments Controller to identify misbehaving actors or the entire contract itself.

---

## Security & Risk Management

### Access Control

The contract implements role-based access control:

|            Role                  | Capabilities                                        |
|:--------------------------------:|:----------------------------------------------------|
| **DEFAULT_ADMIN_ROLE**           | Unpause, freeze, force finalize, manage other roles |
| **VOTING_CONTROLLER_ADMIN_ROLE** | Create/remove pools, set protocol parameters        |
| **CRON_JOB_ROLE**                | End epoch, process verifiers, allocate rewards/subsidies, finalize epochs |
| **CRON_JOB_ADMIN_ROLE**          | Manage CRON_JOB_ROLE members                        |
| **MONITOR_ROLE**                 | Pause contract                                      |
| **MONITOR_ADMIN_ROLE**           | Manage MONITOR_ROLE members                         |
| **ASSET_MANAGER_ROLE**           | Withdraw unclaimed rewards/subsidies/fees           |
| **EMERGENCY_EXIT_HANDLER_ROLE**  | Execute emergency exit when frozen                  |

### Role Hierarchy

```
DEFAULT_ADMIN_ROLE
├── VOTING_CONTROLLER_ADMIN_ROLE
├── EMERGENCY_EXIT_HANDLER_ROLE
├── MONITOR_ADMIN_ROLE
│   └── MONITOR_ROLE
└── CRON_JOB_ADMIN_ROLE
    └── CRON_JOB_ROLE
```

### Operational Risk

- Compromising or misconfiguring any role (cron admin, monitor, default admin, emergency handler) can halt rewards, confiscate balances, or drain the contract
- Admin roles are expected to be held by multi-sigs.
- CronJob and Monitor will be EOA accounts attached to scripts.

### View Functions

The contract provides preview functions for off-chain calculation:
- `viewClaimablePersonalRewards(epoch, user, poolIds)` - Preview personal voting rewards
- `viewClaimableDelegationRewards(epoch, user, delegate, poolIds)` - Unified view for delegation rewards; returns net claimable for user and fees claimable for delegate
- `viewClaimableSubsidies(epoch, poolIds, verifier, verifierAssetManager)` - Preview verifier subsidies
