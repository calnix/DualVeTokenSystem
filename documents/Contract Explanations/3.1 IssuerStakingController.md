# IssuerStakingController Overview

IssuerStakingController.sol lets issuers stake MOCA tokens, with a required delay to unstake. Security is built in with limits, pausing, freezing, and emergency exit features. Only certain roles can take admin actions. 

Off-chain systems check staked balances of issuers to enforce limits on their credential issuances. This is handled within the SDK.

## Table of Contents

- [Key Features](#key-features)
- [1. Contract Overview](#1-contract-overview)
    - [Staking Mechanism](#staking-mechanism)
    - [Unstaking Process](#unstaking-process)
    - [Global State Tracking](#global-state-tracking)
- [2. Design Choices](#2-design-choices)
  - [Time-Delayed Unstaking](#time-delayed-unstaking)
  - [Maximum Stake Limits](#maximum-stake-limits)
  - [Address-Based Issuer Management](#address-based-issuer-management)
- [3. Contract Functions Walkthrough](#3-contract-functions-walkthrough)
  - [stakeMoca()](#stakemoca)
  - [initiateUnstake()](#initiateunstake)
  - [claimUnstake()](#claimunstake)
  - [Administrative Functions](#administrative-functions)
- [4. Execution Flows](#4-execution-flows)
  - [Typical Staking Flow](#typical-staking-flow)
  - [Unstaking and Claiming Flow](#unstaking-and-claiming-flow)
- [5. Integration Points](#5-integration-points)
- [6. Risk Management](#6-risk-management)
- [7. Emergency Procedures](#7-emergency-procedures)
- [8. Upgrade Architecture](#8-upgrade-architecture)
- [Appendix: Technical Deep Dives](#appendix-technical-deep-dives)
  - [Gas Optimization](#gas-optimization)
  - [Precision and Rounding](#precision-and-rounding)
  - [Emergency Scenarios](#emergency-scenarios)

## Key Features

### 1. **Simple Staking Mechanism**
- Direct MOCA token staking with immediate effect
- No complex delegation or voting mechanics

### 2. **Time-Delayed Unstaking System**
- Configurable unstaking delay period (set at deployment)
- Two-phase unstaking: initiate → wait → claim
- Batch claiming support for multiple timestamps

### 3. **Risk Management Controls**
- Maximum stake amount limits to prevent fat-finger mistakes
- Pause/unpause functionality for operational contingencies
- One-way freeze mechanism with emergency exit procedures
- Multi-tiered access control system

### 4. **Global State Tracking**
- Real-time tracking of total MOCA staked across all issuers
- Separate tracking of pending unstake amounts

### 5. **Emergency Recovery Mechanisms**
- Emergency exit function transfers all MOCA to treasury
- Only accessible when contract is frozen
- Ensures user funds remain recoverable under all circumstances

---

# 1. **Contract Overview**

## Staking Mechanism

Issuers can stake MOCA tokens directly to the contract, with immediate effect on their staked balance and the global totals.

```solidity
mapping(address issuer => uint256 mocaStaked) public issuers;
```

**Key Characteristics:**
- **Address-based**: Each issuer address maintains its own staked balance
- **Immediate effect**: Staking takes effect immediately upon transaction confirmation
- **No minimum requirements**: Any amount > 0 and ≤ MAX_STAKE_AMOUNT can be staked
- **Cumulative**: Multiple stakes add to existing balance

## Unstaking Process

The unstaking process is designed with security and predictability in mind:

```solidity
mapping(address issuer => mapping(uint256 timestamp => uint256 pendingUnstake)) public pendingUnstakedMoca;
```

**Two-Phase Process:**
1. **Initiate**: Move tokens from active staked to pending unstake
2. **Claim**: Transfer tokens to issuer after delay period

**Timing Mechanism:**
- Unstaking delay is configurable but immutable after deployment
- Each unstake initiation creates a timestamp-based claimable entry
- Multiple unstakes can be claimed in a single transaction

## Global State Tracking

The contract maintains comprehensive global state for protocol-wide visibility:

```solidity
uint256 public TOTAL_MOCA_STAKED;           // Active staked tokens
uint256 public TOTAL_MOCA_PENDING_UNSTAKE;   // Tokens awaiting claim
uint256 public UNSTAKE_DELAY;               // Delay period for unstaking
uint256 public MAX_STAKE_AMOUNT;            // Maximum single stake amount
```

**State Consistency:**
- Global totals are updated atomically with individual issuer balances
- Pending unstake amounts are tracked separately from active stakes
- All state changes emit events for comprehensive audit trails

---

# 2. **Design Choices**

## Time-Delayed Unstaking

The unstaking delay serves multiple security purposes:

**Rationale:**
- **Slashing Protection**: Prevents immediate withdrawal during disputes
- **Economic Stability**: Reduces volatility from rapid stake changes
- **Operational Safety**: Provides time for emergency procedures if needed

**Implementation:**
- Delay period is set at deployment and can be updated by admin
- Each unstake initiation calculates claimable timestamp: `block.timestamp + UNSTAKE_DELAY`
- Tokens remain in contract during delay period

## Maximum Stake Limits

The `MAX_STAKE_AMOUNT` parameter prevents excessive single transactions:

**Purpose:**
- **Fat-finger Protection**: Prevents accidental large stakes
- **Risk Management**: Limits exposure from single transaction errors
- **Operational Control**: Allows admin to set reasonable limits

**Flexibility:**
- Can be updated by admin as protocol matures
- Applies per transaction, not cumulative balance
- Issuers can stake multiple times up to the limit

## Address-Based Issuer Management

Unlike PaymentsController's ID-based system, IssuerStakingController uses direct address mapping:

**Design Decision:**
- **Simplicity**: Direct address-to-balance mapping
- **Gas Efficiency**: Single mapping lookup instead of ID resolution
- **Compatibility**: Works with existing issuer addresses from PaymentsController

**Trade-offs:**
- **Less Flexible**: Cannot rotate addresses without losing stake
- **Direct Coupling**: Staking tied to specific wallet addresses
- **Migration Complexity**: Moving stakes requires unstaking and re-staking

---

# 3. **Contract Functions Walkthrough**

## `stakeMoca()`

The primary staking function enables issuers to stake MOCA tokens:

```solidity
function stakeMoca(uint256 amount) external whenNotPaused
```

**Process Flow:**
1. **Validation**: Checks amount > 0 and ≤ MAX_STAKE_AMOUNT
2. **State Updates**: Increments issuer balance and global totals
3. **Token Transfer**: Transfers MOCA from issuer to contract
4. **Event Emission**: Records staking event for audit trail

**Gas Optimization:**
- Single storage update per mapping
- Unchecked arithmetic for safe counter increments
- Minimal external calls (only token transfer)

## `initiateUnstake()`

Initiates the unstaking process, moving tokens to pending state:

```solidity
function initiateUnstake(uint256 amount) external whenNotPaused
```

**Process Flow:**
1. **Validation**: Checks amount > 0 and ≤ issuer's staked balance
2. **Timestamp Calculation**: Determines claimable timestamp
3. **State Updates**: 
   - Decrements active staked balance
   - Increments pending unstake amount
   - Updates global totals
4. **Event Emission**: Records unstake initiation with timestamp

**Key Features:**
- **Atomic Updates**: All state changes in single transaction
- **Timestamp-based**: Each unstake gets unique claimable time
- **Batch Support**: Multiple unstakes create separate timestamps

## `claimUnstake()`

Claims unstaked tokens after the delay period:

```solidity
function claimUnstake(uint256[] calldata timestamps) external whenNotPaused
```

**Process Flow:**
1. **Validation**: Checks array length and individual timestamps
2. **Eligibility Check**: Verifies delay period has passed
3. **Amount Calculation**: Sums all claimable amounts
4. **State Cleanup**: Deletes pending entries and updates totals
5. **Token Transfer**: Transfers MOCA to issuer
6. **Event Emission**: Records claim event

**Batch Processing:**
- **Efficiency**: Claim multiple unstakes in single transaction
- **Gas Savings**: Reduces transaction overhead
- **User Experience**: Simplified claiming process

## Administrative Functions

### Parameter Management

**`setUnstakeDelay()`**: Updates the unstaking delay period
- Only callable by IssuerStakingController admin
- Affects future unstake initiations only
- Emits event with old and new values

**`setMaxStakeAmount()`**: Updates maximum stake limit
- Only callable by IssuerStakingController admin
- Affects future stake transactions only
- Emits event with old and new values

---

# 4. **Execution Flows**

## Typical Staking Flow

1. **Issuer Decision**: Issuer decides to stake MOCA tokens
2. **Approval**: Issuer approves MOCA transfer to IssuerStakingController
3. **Stake Transaction**: Issuer calls `stakeMoca(amount)`
4. **Contract Processing**:
   - Validates amount and limits
   - Updates issuer balance and global totals
   - Transfers MOCA tokens
   - Emits staking event
5. **Confirmation**: Staking complete, tokens locked in contract

## Unstaking and Claiming Flow

1. **Unstake Initiation**: Issuer calls `initiateUnstake(amount)`
2. **Contract Processing**:
   - Validates amount against staked balance
   - Calculates claimable timestamp
   - Moves tokens to pending state
   - Emits unstake initiation event
3. **Waiting Period**: Tokens remain locked for UNSTAKE_DELAY
4. **Claim Preparation**: Issuer identifies claimable timestamps
5. **Claim Transaction**: Issuer calls `claimUnstake(timestamps[])`
6. **Contract Processing**:
   - Validates timestamps and amounts
   - Transfers MOCA tokens to issuer
   - Cleans up pending entries
   - Emits claim event

---

# 5. **Integration Points**

## With AddressBook
- **Token Address Resolution**: Reads MOCA token address dynamically
- **Upgrade Support**: Enables seamless contract upgrades
- **Treasury Access**: Emergency exit transfers to treasury address

## With AccessController
- **Role-based Access**: Enforces admin permissions
- **Risk Management**: Integrates with pause/unpause mechanisms
- **Emergency Procedures**: Coordinates with emergency exit handlers

## With PaymentsController
- **Issuer Coordination**: Works with existing issuer addresses
- **Economic Integration**: Staking may influence issuer economics
- **Operational Alignment**: Shares risk management patterns

---

# 6. **Risk Management**

## Access Control Hierarchy

### Operational Roles
- **IssuerStakingController Admin**: Configure parameters and limits
- **Monitor**: Pause contract in emergencies
- **Global Admin**: Unpause and freeze operations
- **Emergency Exit Handler**: Recover funds when frozen

### Security Features

1. **Pausable Operations**
   - All state-changing functions check pause status
   - Monitor can pause, only Global Admin can unpause
   - Prevents damage during active incidents

2. **Freeze Mechanism**
   - One-way operation requiring contract to be paused first
   - Enables emergency exit procedures
   - Cannot be reversed - kill-switch

3. **Parameter Limits**
   - Maximum stake amounts prevent excessive transactions
   - Configurable unstaking delays provide security buffer
   - Admin controls maintain operational flexibility

---

# 7. **Emergency Procedures**

## Emergency Exit Process

The `emergencyExit()` function provides a last-resort recovery mechanism:

```solidity
function emergencyExit() external onlyEmergencyExitHandler
```

**Prerequisites:**
- Contract must be frozen (`isFrozen == 1`)
- Only callable by Emergency Exit Handler role

**Process:**
1. **Validation**: Confirms frozen state and non-zero balances
2. **Treasury Resolution**: Gets treasury address from AddressBook
3. **Amount Calculation**: Sums all staked and pending MOCA
4. **Token Transfer**: Transfers all MOCA to treasury
5. **State Reset**: Clears global totals to zero
6. **Event Emission**: Records emergency exit details

**Recovery Implications:**
- **User Impact**: All staked tokens transferred to treasury
- **State Reset**: Contract totals reset to zero
- **Irreversible**: Cannot be undone once executed
- **Treasury Responsibility**: Treasury must handle user refunds

## Emergency Scenarios

### Scenario 1: Critical Bug Discovery
1. Monitor calls `pause()` - stops all operations
2. Team investigates and determines fix timeline
3. If fixable: Deploy fix, `unpause()` when safe
4. If critical: `freeze()` and initiate emergency exit

### Scenario 2: Malicious Admin
1. Cannot steal funds (only configure parameters)
2. Can manipulate limits (but with transparency via events)
3. Users protected by unstaking delays
4. Worst case: Emergency exit recovers all funds

### Scenario 3: Contract Upgrade Failure
1. Old contract continues operating normally
2. If new contract has issues: revert AddressBook update
3. If migration fails: emergency exit from new problematic contract
4. User funds always recoverable through emergency procedures

---

# 8. **Upgrade Architecture**

## Upgrade Process

1. **Deploy** new IssuerStakingController version
2. **Configure** new contract with existing parameters
3. **Update** AddressBook to point to new contract
4. **Notify** issuers to migrate stakes (unstake → re-stake)
5. **Freeze** old contract once migration complete

## Design for Upgradeability

- **No Direct Dependencies**: Only integrates through AddressBook
- **Clean Interfaces**: Simple staking/unstaking operations
- **State Isolation**: Each issuer's stake is independent
- **Emergency Recovery**: Ensures no funds locked during transition

---

# **Appendix: Technical Deep Dives**

## Gas Optimization

### Storage Access Patterns
```solidity
// Efficient: Direct mapping access
uint256 staked = issuers[msg.sender];        // 100 gas
issuers[msg.sender] += amount;               // 100 gas

// Optimized: Batch operations
TOTAL_MOCA_STAKED += amount;                 // 100 gas
issuers[msg.sender] += amount;               // 100 gas
```

### Unchecked Arithmetic
Safe to use `unchecked` blocks for:
- Counter increments (won't overflow in contract lifetime)
- Balance calculations (already checked for sufficiency)
- Timestamp calculations (safe arithmetic)

## Precision and Rounding

### Token Decimals
- **MOCA**: 18 decimals (1 MOCA = 1,000,000,000,000,000,000 units)
- **No Precision Loss**: All operations maintain full precision
- **Integer Math**: All calculations use integer arithmetic

### Amount Validation
- **Zero Checks**: Prevents zero-amount transactions
- **Limit Enforcement**: MAX_STAKE_AMOUNT prevents excessive stakes
- **Balance Verification**: Ensures sufficient balance for unstaking

## Emergency Scenarios

### Scenario 1: Contract Compromise
1. Monitor detects suspicious activity
2. Calls `pause()` to halt operations
3. Team assesses damage and determines response
4. If recoverable: `unpause()` after fixes
5. If critical: `freeze()` and `emergencyExit()`

### Scenario 2: Parameter Manipulation
1. Admin sets extreme parameters (very long delays, very low limits)
2. Users affected by parameter changes
3. Emergency procedures remain available
4. Community governance can address admin issues

### Scenario 3: Token Contract Issues
1. MOCA token contract experiences problems
2. Staking/unstaking operations may fail
3. Emergency exit provides recovery path
4. Treasury can handle token-related issues

---

## Integration Considerations

### With Voting Systems
- Staked MOCA may influence voting power in other contracts
- Unstaking delays provide stability for governance
- Emergency procedures coordinate with voting mechanisms

### With Economic Models
- Staking may provide economic benefits (subsidies, rewards)
- Unstaking delays prevent rapid economic manipulation
- Global totals enable protocol-wide economic calculations

### With Risk Management
- Pause mechanisms coordinate with other protocol contracts
- Freeze procedures provide system-wide emergency response
- Emergency exit ensures user fund recovery across all scenarios
