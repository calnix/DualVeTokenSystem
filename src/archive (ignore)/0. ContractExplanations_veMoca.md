# Overview

## Time Anchor

    cos' we calculate bias from T0 to Now
    the starting anchor point for the contract is T0
    meaning, 
    - the first week start is T0 
    - the second week start is T0+1 week
    - the third week start is T0+2 weeks
    - etc.

    so on user's passing expiry
    - expiry is specified timestamp representing endTime; not duration
    - expiry is sanitized isValidTime: expiry % Constants.WEEK == 0
    - this ensures that the endTime lies on a week boundary; not inbtw

    this would not be the case if our starting point was some arbitrary time; not T0
    as the weekly count would start at TX, and time checks would have to be done with respect to TX

## User Aggregation

        // book all prior checkpoints | veGlobal not stored
        //DataTypes.VeBalance memory veGlobal_ = _updateGlobal();

        // update user aggregated
        /**
            treat the user as 'global'. 
            must do prior updates to bring user's bias and slope to current week. [_updateGlobal]
            then add new position to user's aggregated veBalance
            then schedule slope changes for the new position

            1. bias
            2. slope
            3. scheduled slope changes
            
            note:
            could possibly skip the prior updates, and just add the new position to user's veBalance + schedule changes
            then have view fn balanceOf do the prior updates. saves gas
         */
        //DataTypes.VeBalance memory veUser = _updateUser(msg.sender);

## Total supply / Total Voting Power

### For historical searches

we are able to obtain the total ve supply or voting power at a specific weekly boundary.
We do so by referencing, the mapping `totalSupplyAt[wTime]`, and passing the timestamp of the weekly boundary.
If we past a timestamp that is not a valid weekly boundary, it will return 0.

We are unable to obtain or interpolate total supply for an arbitrary time in the past, that does not lie on a weekly boundary.
This is because the mapping `totalSupplyAt[wTime]` stores snapshots of supply values, not `VeBalance{bias, slope}` structs.

If we had chosen to store snapshots of structs, it would be possible. However, there does not appear to be a need for it, and is disregarded. 

### For forward-projection

Refer to the state variable `veGlobal`, and calculate the forward decay accordingly.
This is forward decay based on current state.

`lastUpdatedTimestamp` reflects when veGlobal was last updated.

*note: what about forward decay and accounting for incoming slopeChanges?*

## Penalty 

```bash
penaltyPct = (1 - currentVotingPower / initialVotingPower) * MAX_PENALTY_PCT
```

- Calculate penalty based on current veMoca value relative to original veMoca value
- penalizes users based on the proportion of their lock's duration that has elapsed, without needing to store startTime or duration

### Penalty application

- User selects token type: MOCA or esMOCA
- Penalty calculation is based on veMoca value loss, but applied only to the selected token amount
- Token return: User receives the selected token type minus the penalty
- could lead to situations where the selected redemption token is insufficient to bear the penalty

i don't see how we would to partial unstaking for early redemption
penaltyPct is calculated on timeLeft
penaltyAmt = penaltyPct applied on totalPrincipalBase [esMoca + Moca]
penaltyAmt is subtracted from the user's selected principal [either es or moca]
if insufficient, reverts
remaining principal assets returns
how would is the partial unstake amount factored into this process?
also, since there could be a situation where the selected principal token is insufficient to bear the penalty deduction ->  the only sensible way is to:
apply the penalty to the user's choice first.
then the remaining on the other.
finally, return whats left


# Functions

## View functions

1. balanceOf - to query an address's personal voting power
2. balanceOfAt - like balanceOf, but historical search, [since veBalances are stored weekly, find the closest week boundary to the timestamp and interpolate from there]

3. delegatedBalanceOf - to query an address's voting power tt was delegated to it, by other users
4. delegatedBalanceAt - like delegatedBalanceOf; expect historical


# Others

## Tracking what a user has delegated away to others [not implemented]

1. `myDelegated` - for a user to query what he has delegated away to other delegates in totality 
2. `myDelegatedAt` - like myDelegated, but historical search

```solidity 
// Track what each user has delegated to others
mapping(address user => mapping(uint128 wTime => uint128 slopeChange)) public userDelegatedSlopeChanges;
mapping(address user => mapping(uint128 wTime => DataTypes.VeBalance veBalance)) public userDelegatedHistory;
mapping(address user => uint128 lastUpdatedTimestamp) public userDelegatedLastUpdatedTimestamp;
```

```solidity
function myDelegated(address user) external view returns (uint128) {
    // Get the user's delegated away voting power
    DataTypes.VeBalance memory veDelegatedAway = _viewUserDelegated(user);
    return _getValueAt(veDelegatedAway, uint128(block.timestamp));
}
```

```solidity

function myDelegatedAt(address user, uint128 time) external view returns (uint128) {
    require(time <= block.timestamp, "Timestamp is in the future");

    // find the closest weekly boundary (wTime) that is not larger than the input time
    uint128 wTime = WeekMath.getWeekStartTimestamp(time);
    
    // get the user's delegated away veBalance at that weekly boundary
    DataTypes.VeBalance memory veDelegatedAway = userDelegatedHistory[user][wTime];
    
    // calculate the voting power at the exact timestamp using the veBalance from the closest past weekly boundary
    return _getValueAt(veDelegatedAway, time);
}
```

```solidity
function _viewUserDelegated(address user) internal view returns (DataTypes.VeBalance memory) {
    // init user delegated veBalance
    DataTypes.VeBalance memory veDelegatedAway;

    uint128 lastUpdatedAt = userDelegatedLastUpdatedTimestamp[user];
    // if user's first time: no prior updates to execute 
    if(lastUpdatedAt == 0) return veDelegatedAway;

    // load user's previous delegated veBalance
    veDelegatedAway = userDelegatedHistory[user][lastUpdatedAt];
    
    // get current week start
    uint128 currentWeekStart = WeekMath.getWeekStartTimestamp(uint128(block.timestamp)); 
    
    // already up to date: return
    if(lastUpdatedAt >= currentWeekStart) return veDelegatedAway;

    // update user delegated veBalance to current week
    while (lastUpdatedAt < currentWeekStart) {
        lastUpdatedAt += Constants.WEEK;
        uint128 expiringSlope = userDelegatedSlopeChanges[user][lastUpdatedAt];
        veDelegatedAway = subtractExpired(veDelegatedAway, expiringSlope, lastUpdatedAt);
    }

    return veDelegatedAway;
}
```

Will also need to update the following functions:

1. `delegateLock`

```solidity
// Add to user's delegated away balance
DataTypes.VeBalance memory veUserDelegated = _viewUserDelegated(msg.sender);
veUserDelegated = _add(veUserDelegated, lockVeBalance);
userDelegatedHistory[msg.sender][currentWeekStart] = veUserDelegated;
userDelegatedSlopeChanges[msg.sender][lock.expiry] += lockVeBalance.slope;
```

2. undelegateLock

```
// Remove from user's delegated away balance
DataTypes.VeBalance memory veUserDelegated = _viewUserDelegated(msg.sender);
veUserDelegated = _sub(veUserDelegated, lockVeBalance);
userDelegatedHistory[msg.sender][currentWeekStart] = veUserDelegated;
userDelegatedSlopeChanges[msg.sender][lock.expiry] -= lockVeBalance.slope;
```

3. changeDelegate

```
// No change needed - user's total delegated away remains the same
// Just moves from one delegate to another
```